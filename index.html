<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Port.io Implementation Cheat Sheet</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #0f172a; color: #e2e8f0; line-height: 1.6; padding: 20px; }
        .container { max-width: 1400px; margin: 0 auto; }
        
        header { text-align: center; margin-bottom: 30px; padding-bottom: 20px; border-bottom: 1px solid #334155; }
        h1 { font-size: 2.5rem; margin-bottom: 10px; background: linear-gradient(135deg, #60a5fa, #a78bfa); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
        .subtitle { color: #94a3b8; font-size: 1.1rem; }
        .version { color: #64748b; font-size: 0.85rem; margin-top: 8px; }
        
        .header-actions { display: flex; gap: 12px; justify-content: center; margin-top: 15px; flex-wrap: wrap; }
        .header-btn { background: #1e293b; border: 1px solid #334155; color: #e2e8f0; padding: 8px 16px; border-radius: 6px; cursor: pointer; text-decoration: none; font-size: 0.9rem; transition: all 0.2s; }
        .header-btn:hover { background: #334155; border-color: #475569; }
        .header-btn:focus { outline: 2px solid #60a5fa; outline-offset: 2px; }
        
        .notice-box { background: #1e293b; border: 1px solid #334155; border-radius: 8px; padding: 12px 16px; margin-bottom: 20px; font-size: 0.9rem; }
        .notice-box code { background: #334155; padding: 2px 6px; border-radius: 4px; font-family: 'SF Mono', Monaco, monospace; font-size: 0.85em; }
        
        .controls { display: flex; flex-direction: column; gap: 15px; margin-bottom: 25px; }
        .search-box { width: 100%; padding: 12px 16px; font-size: 1rem; border: 2px solid #334155; border-radius: 8px; background: #1e293b; color: #e2e8f0; transition: border-color 0.2s; }
        .search-box:focus { outline: none; border-color: #60a5fa; }
        .search-box::placeholder { color: #64748b; }
        
        .category-filters { display: flex; flex-wrap: wrap; gap: 8px; }
        .category-btn { padding: 8px 16px; border: 1px solid #334155; border-radius: 20px; background: #1e293b; color: #94a3b8; cursor: pointer; transition: all 0.2s; font-size: 0.9rem; }
        .category-btn:hover { border-color: #60a5fa; color: #60a5fa; }
        .category-btn:focus { outline: 2px solid #60a5fa; outline-offset: 2px; }
        .category-btn.active { background: #60a5fa; color: #0f172a; border-color: #60a5fa; }
        
        .status { text-align: center; color: #64748b; padding: 10px; font-size: 0.9rem; }
        
        .pattern-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(400px, 1fr)); gap: 20px; }
        
        .pattern-card { background: #1e293b; border: 1px solid #334155; border-radius: 12px; overflow: hidden; transition: all 0.2s; scroll-margin-top: 20px; }
        .pattern-card:hover { border-color: #475569; transform: translateY(-2px); box-shadow: 0 8px 25px rgba(0,0,0,0.3); }
        .pattern-card:target { border-color: #60a5fa; box-shadow: 0 0 0 2px rgba(96, 165, 250, 0.3); }
        
        .card-header { padding: 16px; border-bottom: 1px solid #334155; position: relative; }
        .card-meta-row { display: flex; gap: 8px; align-items: center; margin-bottom: 8px; }
        .card-category { display: inline-block; padding: 4px 10px; border-radius: 12px; font-size: 0.75rem; font-weight: 600; text-transform: uppercase; }
        .card-title-row { display: flex; align-items: flex-start; justify-content: space-between; gap: 8px; }
        .card-title { font-size: 1.1rem; font-weight: 600; color: #f1f5f9; margin-bottom: 6px; flex: 1; }
        .link-btn { background: transparent; border: 1px solid #475569; color: #64748b; width: 28px; height: 28px; border-radius: 4px; cursor: pointer; font-size: 0.8rem; transition: all 0.2s; flex-shrink: 0; display: flex; align-items: center; justify-content: center; }
        .link-btn:hover { border-color: #60a5fa; color: #60a5fa; background: rgba(96, 165, 250, 0.1); }
        .link-btn:focus { outline: 2px solid #60a5fa; outline-offset: 2px; }
        .link-btn.copied { border-color: #22c55e; color: #22c55e; }
        .card-problem { font-size: 0.85rem; color: #f59e0b; margin-bottom: 6px; }
        .card-description { font-size: 0.9rem; color: #94a3b8; }
        
        .card-body { padding: 16px; }
        .code-block { background: #0f172a; border-radius: 8px; overflow: hidden; margin-bottom: 12px; }
        .code-header { display: flex; justify-content: space-between; align-items: center; padding: 8px 12px; background: #1a2332; border-bottom: 1px solid #334155; }
        .code-label { font-size: 0.75rem; color: #64748b; text-transform: uppercase; }
        .copy-btn { background: #334155; border: none; color: #e2e8f0; padding: 4px 10px; border-radius: 4px; cursor: pointer; font-size: 0.8rem; transition: all 0.2s; }
        .copy-btn:hover { background: #475569; }
        .copy-btn:focus { outline: 2px solid #60a5fa; outline-offset: 2px; }
        .copy-btn.copied { background: #22c55e; }
        pre { margin: 0; padding: 12px; overflow-x: auto; font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace; font-size: 0.85rem; line-height: 1.5; color: #e2e8f0; white-space: pre-wrap; word-wrap: break-word; }
        
        .output-block { background: #0c1222; border: 1px dashed #334155; border-radius: 6px; padding: 10px; margin-top: 10px; }
        .output-label { font-size: 0.7rem; color: #64748b; text-transform: uppercase; margin-bottom: 6px; }
        .output-content { font-family: 'SF Mono', Monaco, monospace; font-size: 0.8rem; color: #94a3b8; white-space: pre-wrap; }
        
        .card-tags { padding: 12px 16px; border-top: 1px solid #334155; display: flex; flex-wrap: wrap; gap: 6px; }
        .tag { background: #334155; color: #94a3b8; padding: 3px 8px; border-radius: 4px; font-size: 0.75rem; }
        
        .cat-blueprints { background: #3b82f6; color: white; }
        .cat-mapping { background: #8b5cf6; color: white; }
        .cat-actions { background: #22c55e; color: white; }
        .cat-scorecards { background: #f59e0b; color: black; }
        .cat-automations { background: #ef4444; color: white; }
        .cat-jq { background: #06b6d4; color: black; }
        .cat-api { background: #ec4899; color: white; }
        .cat-troubleshooting { background: #f97316; color: white; }
        
        .validation-badge { display: inline-flex; align-items: center; gap: 4px; padding: 3px 8px; border-radius: 4px; font-size: 0.7rem; font-weight: 500; margin-left: 8px; }
        .validation-production { background: rgba(34, 197, 94, 0.15); color: #22c55e; border: 1px solid rgba(34, 197, 94, 0.3); }
        .validation-tested { background: rgba(59, 130, 246, 0.15); color: #60a5fa; border: 1px solid rgba(59, 130, 246, 0.3); }
        .validation-adapt { background: rgba(251, 191, 36, 0.15); color: #fbbf24; border: 1px solid rgba(251, 191, 36, 0.3); }
        
        .trust-footer { background: #1e293b; border: 1px solid #334155; border-radius: 8px; padding: 16px; margin-top: 30px; font-size: 0.85rem; }
        .trust-footer-title { font-weight: 600; color: #f1f5f9; margin-bottom: 10px; }
        .trust-legend { display: flex; flex-wrap: wrap; gap: 16px; color: #94a3b8; }
        .trust-item { display: flex; align-items: center; gap: 6px; }
        
        .footer { text-align: center; margin-top: 40px; padding: 20px; color: #64748b; border-top: 1px solid #334155; }
        .footer a { color: #60a5fa; text-decoration: none; }
        .footer a:hover { text-decoration: underline; }
        
        @media (max-width: 600px) {
            .pattern-grid { grid-template-columns: 1fr; }
            h1 { font-size: 1.8rem; }
            .header-actions { flex-direction: column; }
        }
        
        @media print {
            body { background: white; color: black; }
            .controls, .header-actions, .copy-btn, .link-btn, .status { display: none; }
            .pattern-card { break-inside: avoid; page-break-inside: avoid; border: 1px solid #ccc; margin-bottom: 15px; }
            .code-block { background: #f5f5f5; }
            pre { color: black; }
            .card-category { border: 1px solid currentColor; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üöÄ Port.io Implementation Cheat Sheet</h1>
            <p class="subtitle">Copy-paste patterns for blueprints, mappings, actions, and automations</p>
            <p class="version">Last updated: January 5, 2026 ‚Ä¢ v2.3</p>
            <div class="header-actions">
                <button class="header-btn" onclick="window.print()" aria-label="Print this page or save as PDF">üñ®Ô∏è Print / Save PDF</button>
                <a href="https://docs.port.io" target="_blank" class="header-btn" aria-label="Open Port.io documentation">üìö Full Docs</a>
            </div>
        </header>
        
        <div class="notice-box">
            <strong>üìù Placeholders:</strong> Replace <code>&lt;YOUR_ORG&gt;</code>, <code>&lt;YOUR_REPO&gt;</code>, <code>&lt;YOUR_DOMAIN&gt;</code>, <code>$PORT_CLIENT_ID</code>, <code>$PORT_CLIENT_SECRET</code>, <code>$TOKEN</code>, and webhook URLs with your actual values.<br>
            <strong>API Region:</strong> US ‚Üí <code>api.getport.io</code> | EU ‚Üí <code>api.eu.getport.io</code>
        </div>

        <div class="controls">
            <input type="text" class="search-box" id="searchBox" placeholder="Search patterns (e.g., 'kubernetes', 'jq time', 'webhook')..." aria-label="Search patterns">
            <div class="category-filters" role="group" aria-label="Filter by category">
                <button class="category-btn active" data-category="all">All</button>
                <button class="category-btn" data-category="blueprints">Blueprints</button>
                <button class="category-btn" data-category="mapping">Mapping</button>
                <button class="category-btn" data-category="actions">Actions</button>
                <button class="category-btn" data-category="scorecards">Scorecards</button>
                <button class="category-btn" data-category="automations">Automations</button>
                <button class="category-btn" data-category="jq">JQ</button>
                <button class="category-btn" data-category="api">API</button>
                <button class="category-btn" data-category="troubleshooting">Troubleshooting</button>
            </div>
        </div>

        <div class="status" id="status" aria-live="polite">Loading patterns...</div>
        <div class="pattern-grid" id="patternGrid"></div>

        <div class="trust-footer">
            <div class="trust-footer-title">üõ°Ô∏è Pattern Validation</div>
            <div class="trust-legend">
                <span class="trust-item"><span class="validation-badge validation-production">‚úÖ Production</span> Used in real Port implementations</span>
                <span class="trust-item"><span class="validation-badge validation-tested">üß™ Tested</span> Verified in demo environments</span>
                <span class="trust-item"><span class="validation-badge validation-adapt">‚öôÔ∏è Adapt</span> Adjust field names to your blueprints</span>
            </div>
            <p style="margin-top: 12px; color: #64748b;">Patterns are validated conceptually and used in real Port implementations. Exact field names, blueprint identifiers, and schemas may require adaptation to your organization.</p>
        </div>

        <div class="footer">
            üí° Click copy to grab snippets ‚Ä¢ Use üîó to share specific patterns ‚Ä¢ <a href="https://docs.port.io" target="_blank">docs.port.io</a> for full documentation
        </div>
    </div>

    <script>
        const patterns = [
            // ==================== BLUEPRINTS ====================
            {
                id: 'basic-blueprint',
                category: 'blueprints',
                title: 'Basic Blueprint',
                validated: 'adapt',
                problem: 'Need to model a service/resource in Port',
                description: 'Standard blueprint with string, number, boolean, and enum properties plus a required relation.',
                code: `{
  "identifier": "microservice",
  "title": "Microservice",
  "icon": "Service",
  "schema": {
    "properties": {
      "language": {
        "type": "string",
        "enum": ["Python", "Node", "Go", "Java"],
        "title": "Language"
      },
      "version": { "type": "string", "title": "Version" },
      "replicas": { "type": "number", "default": 1 },
      "on_call": { "type": "string", "format": "user" },
      "is_production": { "type": "boolean", "default": false }
    },
    "required": ["language"]
  },
  "relations": {
    "team": {
      "target": "team",
      "required": true,
      "many": false,
      "title": "Owning Team"
    }
  }
}`,
                output: 'Creates blueprint in Port catalog',
                tags: ['blueprint', 'schema', 'properties', 'relations']
            },
            {
                id: 'arrays-objects',
                validated: 'adapt',
                category: 'blueprints',
                title: 'Arrays & Objects',
                problem: 'Need to store lists or complex nested data',
                description: 'Blueprint with array and object property types for structured data.',
                code: `{
  "identifier": "deployment",
  "schema": {
    "properties": {
      "environments": {
        "type": "array",
        "items": { "type": "string" },
        "title": "Environments"
      },
      "config": {
        "type": "object",
        "title": "Configuration"
      },
      "urls": {
        "type": "array",
        "items": { "type": "string", "format": "url" },
        "title": "URLs"
      }
    }
  }
}`,
                output: 'Supports ["dev","staging","prod"] and {"key": "value"}',
                tags: ['blueprint', 'array', 'object', 'nested']
            },
            {
                id: 'mirror-property',
                validated: 'adapt',
                category: 'blueprints',
                title: 'Mirror Property',
                problem: 'Want to display data from a related entity',
                description: 'Mirror pulls property values from related entities for display.',
                code: `{
  "identifier": "service",
  "schema": {
    "properties": {
      "team_slack": {
        "type": "string",
        "title": "Team Slack Channel"
      }
    }
  },
  "mirrorProperties": {
    "owner_email": {
      "path": "team.owner_email",
      "title": "Team Owner Email"
    }
  }
}`,
                output: 'Displays team owner email on service entity',
                tags: ['blueprint', 'mirror', 'relation', 'display']
            },
            {
                id: 'calculation-property',
                validated: 'adapt',
                category: 'blueprints',
                title: 'Calculation Property',
                problem: 'Need computed values from entity properties',
                description: 'Calculation properties use JQ to derive values from other properties.',
                code: `{
  "identifier": "service",
  "calculationProperties": {
    "health_status": {
      "title": "Health Status",
      "type": "string",
      "colorized": true,
      "colors": {
        "healthy": "green",
        "degraded": "yellow",
        "critical": "red"
      },
      "calculation": "if .properties.error_rate > 5 then \\"critical\\" elif .properties.error_rate > 1 then \\"degraded\\" else \\"healthy\\" end"
    },
    "display_name": {
      "title": "Display Name",
      "type": "string",
      "calculation": ".title + \\" (\\" + .properties.environment + \\")\\"" 
    }
  }
}`,
                output: 'Auto-calculates health_status based on error_rate',
                tags: ['blueprint', 'calculation', 'jq', 'computed']
            },
            {
                id: 'aggregation-property',
                validated: 'adapt',
                category: 'blueprints',
                title: 'Aggregation Property',
                problem: 'Need to count or aggregate related entities',
                description: 'Aggregations compute metrics across related entities. Query rules reference the relation property.',
                code: `{
  "identifier": "team",
  "aggregationProperties": {
    "service_count": {
      "title": "Services Owned",
      "type": "number",
      "target": "service",
      "query": {
        "combinator": "and",
        "rules": [{ "property": "$team", "operator": "=" }]
      },
      "calculationSpec": {
        "calculationBy": "entities",
        "func": "count"
      }
    },
    "avg_coverage": {
      "title": "Avg Test Coverage",
      "type": "number",
      "target": "service",
      "query": {
        "combinator": "and",
        "rules": [{ "property": "$team", "operator": "=" }]
      },
      "calculationSpec": {
        "calculationBy": "property",
        "property": "test_coverage",
        "func": "average"
      }
    }
  }
}`,
                output: 'Shows count of services and average coverage per team',
                tags: ['blueprint', 'aggregation', 'count', 'average', 'metrics']
            },
            // ==================== MAPPING ====================
            {
                id: 'github-repo-mapping',
                validated: 'adapt',
                category: 'mapping',
                title: 'GitHub Repository Mapping',
                problem: 'Import repos from GitHub into Port',
                description: 'Maps GitHub repository data to Port entities via the GitHub integration.',
                code: `resources:
  - kind: repository
    selector:
      query: 'true'
    port:
      entity:
        mappings:
          identifier: .name
          title: .name
          blueprint: '"repository"'
          properties:
            url: .html_url
            description: .description
            language: .language
            default_branch: .default_branch
            visibility: .visibility
            created_at: .created_at
            updated_at: .updated_at
          relations:
            owner: .owner.login`,
                output: 'Syncs repositories to Port catalog',
                tags: ['mapping', 'github', 'repository', 'integration']
            },
            {
                id: 'k8s-deployment-mapping',
                validated: 'adapt',
                category: 'mapping',
                title: 'Kubernetes Deployment Mapping',
                problem: 'Import K8s deployments into Port',
                description: 'Maps Kubernetes deployment resources to Port entities. Resource kind format may vary by exporter.',
                code: `resources:
  - kind: apps/v1/deployments
    selector:
      query: .metadata.namespace | startswith("kube-") | not
    port:
      entity:
        mappings:
          identifier: .metadata.namespace + "-" + .metadata.name
          title: .metadata.name
          blueprint: '"deployment"'
          properties:
            namespace: .metadata.namespace
            replicas: .spec.replicas
            available: .status.availableReplicas // 0
            image: .spec.template.spec.containers[0].image
            labels: .metadata.labels
            created_at: .metadata.creationTimestamp
          relations:
            cluster: env.CLUSTER_NAME
            namespace: .metadata.namespace`,
                output: 'Syncs deployments excluding kube-* namespaces',
                tags: ['mapping', 'kubernetes', 'k8s', 'deployment']
            },
            {
                id: 'argocd-app-mapping',
                validated: 'adapt',
                category: 'mapping',
                title: 'ArgoCD Application Mapping',
                problem: 'Import ArgoCD apps with sync status',
                description: 'Maps ArgoCD application state and health to Port.',
                code: `resources:
  - kind: application
    selector:
      query: 'true'
    port:
      entity:
        mappings:
          identifier: .metadata.name
          title: .metadata.name
          blueprint: '"argoApplication"'
          properties:
            sync_status: .status.sync.status
            health_status: .status.health.status
            repo_url: .spec.source.repoURL
            path: .spec.source.path
            target_revision: .spec.source.targetRevision
            destination_server: .spec.destination.server
            destination_namespace: .spec.destination.namespace
            last_synced: .status.operationState.finishedAt
          relations:
            cluster: .spec.destination.name`,
                output: 'Tracks ArgoCD sync and health status',
                tags: ['mapping', 'argocd', 'gitops', 'sync']
            },
            {
                id: 'terraform-workspace-mapping',
                validated: 'adapt',
                category: 'mapping',
                title: 'Terraform Cloud Workspace',
                problem: 'Import Terraform workspaces into Port',
                description: 'Maps Terraform Cloud workspace state to Port.',
                code: `resources:
  - kind: workspace
    selector:
      query: 'true'
    port:
      entity:
        mappings:
          identifier: .id
          title: .attributes.name
          blueprint: '"terraformWorkspace"'
          properties:
            environment: .attributes.environment
            terraform_version: .attributes."terraform-version"
            auto_apply: .attributes."auto-apply"
            working_directory: .attributes."working-directory"
            execution_mode: .attributes."execution-mode"
            vcs_repo: .attributes."vcs-repo".identifier
            last_run_status: .__latestRun.attributes.status
            resources_count: .__stateVersion.attributes."resources-count"
          relations:
            project: .relationships.project.data.id`,
                output: 'Syncs TFC workspaces with run status',
                tags: ['mapping', 'terraform', 'tfc', 'iac']
            },
            {
                id: 'search-relation',
                validated: 'adapt',
                category: 'mapping',
                title: 'Rule-Based Relation Matching',
                problem: 'Create relations based on matching properties',
                description: 'Uses query rules to dynamically match related entities by property value.',
                code: `resources:
  - kind: deployment
    port:
      entity:
        mappings:
          identifier: .metadata.name
          blueprint: '"deployment"'
          relations:
            service:
              combinator: '"and"'
              rules:
                - property: '"identifier"'
                  operator: '"="'
                  value: .metadata.labels.app
            environment:
              combinator: '"and"'
              rules:
                - property: '"name"'
                  operator: '"contains"'
                  value: .metadata.namespace`,
                output: 'Matches deployment to service by label',
                tags: ['mapping', 'relation', 'search', 'dynamic']
            },
            {
                id: 'webhook-mapping',
                validated: 'adapt',
                category: 'mapping',
                title: 'Generic Webhook Mapping',
                problem: 'Ingest data from any webhook source',
                description: 'Process incoming webhook payloads and map to Port entities.',
                code: `# Webhook URL format:
# https://ingest.getport.io/<YOUR_WEBHOOK_ID>

# Mapping configuration in Port UI:
{
  "identifier": ".body.id | tostring",
  "title": ".body.name",
  "blueprint": "\\"externalService\\"",
  "properties": {
    "status": ".body.status",
    "environment": ".headers.\\"X-Environment\\" // \\"unknown\\"",
    "payload": ".body",
    "received_at": "now | todateiso8601"
  }
}

# Test with curl:
curl -X POST "https://ingest.getport.io/<YOUR_WEBHOOK_ID>" \\
  -H "Content-Type: application/json" \\
  -H "X-Environment: production" \\
  -d '{"id": 123, "name": "test-service", "status": "active"}'`,
                output: 'Creates entity from any POST payload',
                tags: ['mapping', 'webhook', 'ingest', 'custom']
            },
            // ==================== ACTIONS ====================
            {
                id: 'basic-self-service-action',
                validated: 'adapt',
                category: 'actions',
                title: 'Basic Self-Service Action',
                problem: 'Enable developers to trigger operations',
                description: 'Self-service action with text input that triggers a GitHub workflow.',
                code: `{
  "identifier": "scaffold_service",
  "title": "Scaffold New Service",
  "icon": "Microservice",
  "trigger": {
    "type": "self-service",
    "operation": "CREATE",
    "blueprintIdentifier": "service"
  },
  "invocationMethod": {
    "type": "GITHUB",
    "org": "<YOUR_ORG>",
    "repo": "<YOUR_REPO>",
    "workflow": "scaffold.yml",
    "workflowInputs": {
      "service_name": "{{ .inputs.service_name }}",
      "language": "{{ .inputs.language }}",
      "port_context": "{{ .trigger | toJson }}"
    }
  },
  "userInputs": {
    "properties": {
      "service_name": {
        "type": "string",
        "title": "Service Name",
        "pattern": "^[a-z][a-z0-9-]*$"
      },
      "language": {
        "type": "string",
        "enum": ["python", "node", "go"],
        "default": "python"
      }
    },
    "required": ["service_name"]
  }
}`,
                output: 'Triggers scaffold.yml with service_name input',
                tags: ['action', 'self-service', 'github', 'scaffold']
            },
            {
                id: 'entity-selection-input',
                validated: 'adapt',
                category: 'actions',
                title: 'Entity Selection Input',
                problem: 'Let users pick from existing entities',
                description: 'Action input that presents a dropdown of entities from a blueprint.',
                code: `{
  "identifier": "deploy_to_cluster",
  "title": "Deploy to Cluster",
  "trigger": {
    "type": "self-service",
    "operation": "DAY-2",
    "blueprintIdentifier": "service"
  },
  "userInputs": {
    "properties": {
      "target_cluster": {
        "type": "string",
        "format": "entity",
        "blueprint": "cluster",
        "title": "Target Cluster",
        "description": "Select deployment target"
      },
      "target_namespace": {
        "type": "string",
        "format": "entity",
        "blueprint": "namespace",
        "title": "Namespace",
        "dependsOn": ["target_cluster"],
        "dataset": {
          "combinator": "and",
          "rules": [{
            "property": "$relation.cluster",
            "operator": "=",
            "value": "{{ .inputs.target_cluster }}"
          }]
        }
      }
    },
    "required": ["target_cluster", "target_namespace"]
  }
}`,
                output: 'Cascading dropdowns: cluster ‚Üí filtered namespaces',
                tags: ['action', 'entity', 'dropdown', 'cascade', 'dependsOn']
            },
            {
                id: 'create-entity-action',
                validated: 'adapt',
                category: 'actions',
                title: 'Create Entity Action',
                problem: 'Create new entities via self-service',
                description: 'Action that creates a new entity in Port when triggered.',
                code: `{
  "identifier": "create_environment",
  "title": "Create Environment",
  "trigger": {
    "type": "self-service",
    "operation": "CREATE",
    "blueprintIdentifier": "environment"
  },
  "invocationMethod": {
    "type": "WEBHOOK",
    "url": "https://api.getport.io/v1/blueprints/environment/entities",
    "method": "POST",
    "headers": {
      "Authorization": "Bearer {{ .secrets.PORT_CLIENT_SECRET }}"
    },
    "body": {
      "identifier": "{{ .inputs.env_name }}",
      "title": "{{ .inputs.env_name | title }}",
      "properties": {
        "type": "{{ .inputs.env_type }}",
        "region": "{{ .inputs.region }}"
      },
      "relations": {
        "cluster": "{{ .inputs.cluster }}"
      }
    }
  }
}`,
                output: 'Creates environment entity via Port API',
                tags: ['action', 'create', 'entity', 'webhook']
            },
            {
                id: 'action-with-approval',
                validated: 'adapt',
                category: 'actions',
                title: 'Action with Approval',
                problem: 'Require approval before execution',
                description: 'Action requiring manual approval from specified users/teams.',
                code: `{
  "identifier": "promote_to_prod",
  "title": "Promote to Production",
  "trigger": {
    "type": "self-service",
    "operation": "DAY-2",
    "blueprintIdentifier": "service"
  },
  "requiredApproval": {
    "type": "ANY",
    "approvers": {
      "users": ["admin@company.com"],
      "teams": ["platform-team"]
    }
  },
  "invocationMethod": {
    "type": "GITHUB",
    "org": "<YOUR_ORG>",
    "repo": "<YOUR_REPO>",
    "workflow": "promote.yml"
  }
}`,
                output: 'Requires 1 approval from admin or platform-team',
                tags: ['action', 'approval', 'governance', 'production']
            },
            {
                id: 'webhook-action',
                validated: 'adapt',
                category: 'actions',
                title: 'Webhook Action',
                problem: 'Trigger external systems via HTTP',
                description: 'Action that calls any HTTP endpoint with custom payload.',
                code: `{
  "identifier": "trigger_pipeline",
  "title": "Trigger CI Pipeline",
  "trigger": {
    "type": "self-service",
    "operation": "DAY-2",
    "blueprintIdentifier": "service"
  },
  "invocationMethod": {
    "type": "WEBHOOK",
    "url": "https://api.example.com/pipelines",
    "method": "POST",
    "headers": {
      "Authorization": "Bearer {{ .secrets.PIPELINE_TOKEN }}",
      "Content-Type": "application/json"
    },
    "body": {
      "service": "{{ .entity.identifier }}",
      "branch": "{{ .inputs.branch }}",
      "triggered_by": "{{ .trigger.by.user.email }}"
    }
  }
}`,
                output: 'POSTs to external API with entity context',
                tags: ['action', 'webhook', 'http', 'integration']
            },
            // ==================== SCORECARDS ====================
            {
                id: 'production-readiness-scorecard',
                validated: 'adapt',
                category: 'scorecards',
                title: 'Production Readiness Scorecard',
                problem: 'Measure if services meet production standards',
                description: 'Multi-level scorecard checking documentation, monitoring, and security.',
                code: `{
  "identifier": "production_readiness",
  "title": "Production Readiness",
  "blueprint": "service",
  "levels": [
    { "title": "Bronze", "color": "bronze" },
    { "title": "Silver", "color": "silver" },
    { "title": "Gold", "color": "gold" }
  ],
  "rules": [
    {
      "identifier": "has_readme",
      "title": "Has README",
      "level": "Bronze",
      "query": {
        "combinator": "and",
        "conditions": [
          { "property": "readme_url", "operator": "isNotEmpty" }
        ]
      }
    },
    {
      "identifier": "has_monitoring",
      "title": "Monitoring Configured",
      "level": "Silver",
      "query": {
        "combinator": "and",
        "conditions": [
          { "property": "grafana_dashboard", "operator": "isNotEmpty" },
          { "property": "pagerduty_service", "operator": "isNotEmpty" }
        ]
      }
    },
    {
      "identifier": "security_scan",
      "title": "Security Scan Passing",
      "level": "Gold",
      "query": {
        "combinator": "and",
        "conditions": [
          { "property": "security_score", "operator": ">=", "value": 80 }
        ]
      }
    }
  ]
}`,
                output: 'Services progress Bronze ‚Üí Silver ‚Üí Gold',
                tags: ['scorecard', 'production', 'readiness', 'levels']
            },
            {
                id: 'time-based-rule',
                validated: 'adapt',
                category: 'scorecards',
                title: 'Time-Based Rule',
                problem: 'Check if property was updated recently',
                description: 'Scorecard rule checking property freshness with date comparison.',
                code: `{
  "rules": [
    {
      "identifier": "recent_deploy",
      "title": "Deployed in Last 30 Days",
      "level": "Silver",
      "query": {
        "combinator": "and",
        "conditions": [
          {
            "property": "last_deployed_at",
            "operator": "between",
            "value": {
              "preset": "lastMonth"
            }
          }
        ]
      }
    },
    {
      "identifier": "not_stale",
      "title": "Not Stale (updated in 90 days)",
      "level": "Bronze",
      "query": {
        "combinator": "and",
        "conditions": [
          {
            "property": "$updatedAt",
            "operator": ">=",
            "value": {
              "jqQuery": "now - (90 * 24 * 60 * 60) | todateiso8601"
            }
          }
        ]
      }
    }
  ]
}`,
                output: 'Passes if deployed within 30 days',
                tags: ['scorecard', 'time', 'date', 'freshness']
            },
            {
                id: 'mirror-property-scorecard',
                validated: 'adapt',
                category: 'scorecards',
                title: 'Scorecard on Mirror Property',
                problem: 'Score based on related entity data',
                description: 'Use mirror properties in scorecard rules to check related entity values.',
                code: `{
  "identifier": "team_compliance",
  "title": "Team Compliance",
  "blueprint": "service",
  "rules": [
    {
      "identifier": "team_has_oncall",
      "title": "Team Has On-Call Rotation",
      "level": "Bronze",
      "query": {
        "combinator": "and",
        "conditions": [
          {
            "property": "$team.pagerduty_schedule",
            "operator": "isNotEmpty"
          }
        ]
      }
    },
    {
      "identifier": "team_size_ok",
      "title": "Team Has 3+ Members",
      "level": "Silver",
      "query": {
        "combinator": "and",
        "conditions": [
          {
            "property": "$team.member_count",
            "operator": ">=",
            "value": 3
          }
        ]
      }
    }
  ]
}`,
                output: 'Checks team properties via relation',
                tags: ['scorecard', 'mirror', 'relation', 'team']
            },
            // ==================== AUTOMATIONS ====================
            {
                id: 'entity-created-trigger',
                validated: 'adapt',
                category: 'automations',
                title: 'Entity Created Trigger',
                problem: 'Take action when new entity appears',
                description: 'Automation that fires when an entity is created.',
                code: `{
  "identifier": "notify_new_service",
  "title": "Notify on New Service",
  "trigger": {
    "type": "automation",
    "event": {
      "type": "ENTITY_CREATED",
      "blueprintIdentifier": "service"
    }
  },
  "invocationMethod": {
    "type": "WEBHOOK",
    "url": "https://hooks.slack.com/services/XXX/YYY/ZZZ",
    "method": "POST",
    "body": {
      "text": "New service created: {{ .event.context.entityIdentifier }} by {{ .event.context.user.email }}"
    }
  }
}`,
                output: 'Posts to Slack when service created',
                tags: ['automation', 'created', 'webhook', 'slack']
            },
            {
                id: 'entity-updated-trigger',
                validated: 'adapt',
                category: 'automations',
                title: 'Entity Updated Trigger',
                problem: 'React to property changes',
                description: 'Automation with conditions that fires only on specific changes.',
                code: `{
  "identifier": "sync_on_version_change",
  "title": "Sync on Version Change",
  "trigger": {
    "type": "automation",
    "event": {
      "type": "ENTITY_UPDATED",
      "blueprintIdentifier": "service"
    },
    "condition": {
      "type": "JQ",
      "expressions": [
        ".diff.before.properties.version != .diff.after.properties.version"
      ],
      "combinator": "and"
    }
  },
  "invocationMethod": {
    "type": "GITHUB",
    "org": "<YOUR_ORG>",
    "repo": "<YOUR_REPO>",
    "workflow": "sync.yml",
    "workflowInputs": {
      "service": "{{ .event.context.entityIdentifier }}",
      "old_version": "{{ .event.diff.before.properties.version }}",
      "new_version": "{{ .event.diff.after.properties.version }}"
    }
  }
}`,
                output: 'Triggers only when version property changes',
                tags: ['automation', 'updated', 'diff', 'condition']
            },
            {
                id: 'timer-property-expired',
                validated: 'adapt',
                category: 'automations',
                title: 'Timer Property Expired',
                problem: 'Run automation when a date property passes',
                description: 'Automation that fires when a timer/date property value is reached.',
                code: `{
  "identifier": "daily_stale_check",
  "title": "Daily Stale Service Check",
  "trigger": {
    "type": "automation",
    "event": {
      "type": "TIMER_PROPERTY_EXPIRED",
      "blueprintIdentifier": "service",
      "propertyIdentifier": "next_review_date"
    }
  },
  "invocationMethod": {
    "type": "WEBHOOK",
    "url": "https://api.example.com/reviews/remind",
    "method": "POST",
    "body": {
      "service": "{{ .event.context.entityIdentifier }}",
      "owner": "{{ .event.context.entity.relations.team }}"
    }
  }
}`,
                output: 'Fires when next_review_date passes',
                tags: ['automation', 'timer', 'date', 'expiry']
            },
            {
                id: 'scorecard-change-trigger',
                validated: 'adapt',
                category: 'automations',
                title: 'Scorecard Change Trigger',
                problem: 'React when scorecard level changes',
                description: 'Automation that fires when scorecard level increases or decreases.',
                code: `{
  "identifier": "celebrate_gold",
  "title": "Celebrate Gold Achievement",
  "trigger": {
    "type": "automation",
    "event": {
      "type": "ENTITY_UPDATED",
      "blueprintIdentifier": "service"
    },
    "condition": {
      "type": "JQ",
      "expressions": [
        ".diff.after.scorecards.production_readiness.level == \\"Gold\\"",
        ".diff.before.scorecards.production_readiness.level != \\"Gold\\""
      ],
      "combinator": "and"
    }
  },
  "invocationMethod": {
    "type": "WEBHOOK",
    "url": "https://hooks.slack.com/services/XXX",
    "method": "POST",
    "body": {
      "text": "üèÜ {{ .event.context.entityIdentifier }} achieved Gold production readiness!"
    }
  }
}`,
                output: 'Posts to Slack when service reaches Gold',
                tags: ['automation', 'scorecard', 'level', 'celebration']
            },
            // ==================== JQ ====================
            {
                id: 'jq-default-values',
                validated: 'adapt',
                category: 'jq',
                title: 'Default Values',
                problem: 'Handle null/missing fields safely',
                description: 'JQ patterns for providing fallback values.',
                code: `# Alternative operator (if null or false)
.properties.replicas // 1

# Empty string fallback
.properties.description // ""

# Nested with default
.metadata.labels.app // .metadata.name // "unknown"

# Type-safe default (only if null)
if .properties.count == null then 0 else .properties.count end

# Default for missing key
(.properties.tags // []) | join(",")`,
                output: 'Returns fallback when value is null/missing',
                tags: ['jq', 'default', 'null', 'fallback']
            },
            {
                id: 'jq-string-manipulation',
                validated: 'adapt',
                category: 'jq',
                title: 'String Manipulation',
                problem: 'Transform strings in mappings',
                description: 'Common JQ string operations.',
                code: `# Concatenation
.namespace + "-" + .name

# Interpolation (in JQ, not JS)
"service-\\(.metadata.name)-\\(.metadata.namespace)"

# Case conversion
.name | ascii_downcase
.name | ascii_upcase

# Split and join
.image | split(":") | .[0]              # Get image name without tag
.tags | join(", ")                       # Array to comma-separated

# Replace
.url | gsub("http://"; "https://")

# Regex extract
.image | capture("(?<repo>.*):(?<tag>.*)") | .tag`,
                output: 'Various string transformations',
                tags: ['jq', 'string', 'concat', 'split', 'regex']
            },
            {
                id: 'jq-array-operations',
                validated: 'adapt',
                category: 'jq',
                title: 'Array Operations',
                problem: 'Filter and transform arrays',
                description: 'JQ patterns for working with arrays.',
                code: `# Filter array
.items | map(select(.status == "active"))

# Get first/last
.containers | first
.containers | last

# Check if contains
.tags | contains(["production"])

# Check any/all
[.rules[].passing] | all
[.checks[].status] | any(. == "failed")

# Unique values
[.pods[].status] | unique

# Array length
.replicas | length

# Flatten nested
.spec.containers | map(.ports) | flatten`,
                output: 'Filtered/transformed arrays',
                tags: ['jq', 'array', 'filter', 'map', 'select']
            },
            {
                id: 'jq-date-handling',
                validated: 'adapt',
                category: 'jq',
                title: 'Date Handling',
                problem: 'Work with timestamps and dates',
                description: 'JQ date parsing and formatting.',
                code: `# Current timestamp (ISO 8601)
now | todateiso8601

# Parse ISO date to epoch
.created_at | fromdateiso8601

# Format epoch to readable
.timestamp | strftime("%Y-%m-%d %H:%M:%S")

# Days since date
((now - (.last_updated | fromdateiso8601)) / 86400) | floor

# Date comparison
.expires_at | fromdateiso8601 > now

# Add days to date
(.created_at | fromdateiso8601) + (7 * 86400) | todateiso8601`,
                output: 'Date calculations and formatting',
                tags: ['jq', 'date', 'time', 'timestamp', 'iso8601']
            },
            {
                id: 'jq-automation-conditions',
                validated: 'adapt',
                category: 'jq',
                title: 'Automation Conditions',
                problem: 'Write complex automation trigger conditions',
                description: 'JQ patterns for automation condition expressions.',
                code: `# Check specific property changed
.diff.before.properties.status != .diff.after.properties.status

# Check property changed to specific value
.diff.after.properties.status == "deployed" and .diff.before.properties.status != "deployed"

# Check scorecard level improved
(.diff.after.scorecards.readiness.level == "Gold") and (.diff.before.scorecards.readiness.level != "Gold")

# Check relation was added
(.diff.after.relations.team != null) and (.diff.before.relations.team == null)

# Check array property contains value
.diff.after.properties.environments | contains(["production"])

# Combined conditions
(.diff.after.properties.is_production == true) and (.diff.after.scorecards.security.level != "Gold")`,
                output: 'Boolean expression for automation trigger',
                tags: ['jq', 'automation', 'condition', 'diff', 'trigger']
            },
            // ==================== API ====================
            {
                id: 'api-authentication',
                validated: 'adapt',
                category: 'api',
                title: 'API Authentication',
                problem: 'Get access token for Port API',
                description: 'Exchange client credentials for JWT token.',
                code: `# Get access token
curl -s -X POST "https://api.getport.io/v1/auth/access_token" \\
  -H "Content-Type: application/json" \\
  -d '{
    "clientId": "'"$PORT_CLIENT_ID"'",
    "clientSecret": "'"$PORT_CLIENT_SECRET"'"
  }' | jq -r '.accessToken'

# Store token for subsequent requests
export TOKEN=$(curl -s -X POST "https://api.getport.io/v1/auth/access_token" \\
  -H "Content-Type: application/json" \\
  -d '{"clientId":"'"$PORT_CLIENT_ID"'","clientSecret":"'"$PORT_CLIENT_SECRET"'"}' \\
  | jq -r '.accessToken')

# Use in requests
curl -H "Authorization: Bearer $TOKEN" \\
  "https://api.getport.io/v1/blueprints"`,
                output: 'Returns JWT access token (refresh as needed)',
                tags: ['api', 'auth', 'token', 'curl']
            },
            {
                id: 'api-entity-crud',
                validated: 'adapt',
                category: 'api',
                title: 'Entity CRUD Operations',
                problem: 'Create, read, update, delete entities',
                description: 'Basic API operations for entity management.',
                code: `# Create entity
curl -X POST "https://api.getport.io/v1/blueprints/service/entities" \\
  -H "Authorization: Bearer $TOKEN" \\
  -H "Content-Type: application/json" \\
  -d '{
    "identifier": "my-service",
    "title": "My Service",
    "properties": {"language": "python", "version": "1.0.0"},
    "relations": {"team": "platform"}
  }'

# Get entity
curl "https://api.getport.io/v1/blueprints/service/entities/my-service" \\
  -H "Authorization: Bearer $TOKEN"

# Update entity (merge)
curl -X PATCH "https://api.getport.io/v1/blueprints/service/entities/my-service" \\
  -H "Authorization: Bearer $TOKEN" \\
  -H "Content-Type: application/json" \\
  -d '{"properties": {"version": "1.1.0"}}'

# Delete entity
curl -X DELETE "https://api.getport.io/v1/blueprints/service/entities/my-service" \\
  -H "Authorization: Bearer $TOKEN"`,
                output: 'Standard REST operations',
                tags: ['api', 'entity', 'crud', 'rest']
            },
            {
                id: 'api-search-entities',
                validated: 'adapt',
                category: 'api',
                title: 'Search Entities',
                problem: 'Query entities with filters',
                description: 'Search API with query rules.',
                code: `# Search with filter
curl -X POST "https://api.getport.io/v1/blueprints/service/entities/search" \\
  -H "Authorization: Bearer $TOKEN" \\
  -H "Content-Type: application/json" \\
  -d '{
    "combinator": "and",
    "rules": [
      {"property": "language", "operator": "=", "value": "python"},
      {"property": "is_production", "operator": "=", "value": true}
    ]
  }'

# Search with relation filter
curl -X POST "https://api.getport.io/v1/blueprints/service/entities/search" \\
  -H "Authorization: Bearer $TOKEN" \\
  -H "Content-Type: application/json" \\
  -d '{
    "combinator": "and",
    "rules": [
      {"property": "$relation.team", "operator": "=", "value": "platform"}
    ]
  }'`,
                output: 'Returns matching entities array',
                tags: ['api', 'search', 'query', 'filter']
            },
            {
                id: 'api-action-run-status',
                validated: 'adapt',
                category: 'api',
                title: 'Update Action Run Status',
                problem: 'Report action success/failure back to Port',
                description: 'Update action run status from GitHub Action or webhook handler.',
                code: `# Report success (use in GitHub Actions or scripts)
curl -X PATCH "https://api.getport.io/v1/actions/runs/$PORT_RUN_ID" \\
  -H "Authorization: Bearer $TOKEN" \\
  -H "Content-Type: application/json" \\
  -d '{
    "status": "SUCCESS",
    "summary": "Deployment completed successfully",
    "link": "https://github.com/org/repo/actions/runs/123"
  }'

# Report failure with message
curl -X PATCH "https://api.getport.io/v1/actions/runs/$PORT_RUN_ID" \\
  -H "Authorization: Bearer $TOKEN" \\
  -H "Content-Type: application/json" \\
  -d '{
    "status": "FAILURE",
    "summary": "Deployment failed: '"$ERROR_MSG"'"
  }'

# Add log entries during execution
curl -X POST "https://api.getport.io/v1/actions/runs/$PORT_RUN_ID/logs" \\
  -H "Authorization: Bearer $TOKEN" \\
  -H "Content-Type: application/json" \\
  -d '{"message": "Step 1: Building image..."}'`,
                output: 'Updates action status in Port UI',
                tags: ['api', 'action', 'run', 'status', 'github']
            },
            {
                id: 'api-bulk-upsert',
                validated: 'adapt',
                category: 'api',
                title: 'Bulk Upsert Entities',
                problem: 'Create/update many entities at once',
                description: 'Efficient bulk operations for large datasets.',
                code: `# Bulk upsert (create or update)
curl -X POST "https://api.getport.io/v1/blueprints/service/entities" \\
  -H "Authorization: Bearer $TOKEN" \\
  -H "Content-Type: application/json" \\
  -d '{
    "entities": [
      {
        "identifier": "service-1",
        "title": "Service 1",
        "properties": {"language": "python"}
      },
      {
        "identifier": "service-2", 
        "title": "Service 2",
        "properties": {"language": "node"}
      }
    ]
  }'

# Bulk delete
curl -X DELETE "https://api.getport.io/v1/blueprints/service/entities" \\
  -H "Authorization: Bearer $TOKEN" \\
  -H "Content-Type: application/json" \\
  -d '{
    "identifiers": ["service-1", "service-2"]
  }'`,
                output: 'Creates/updates multiple entities in one call',
                tags: ['api', 'bulk', 'upsert', 'batch']
            },
            // ==================== TROUBLESHOOTING ====================
            {
                id: 'ts-entity-not-showing',
                validated: 'adapt',
                category: 'troubleshooting',
                title: 'Entity Not Showing Up',
                problem: 'Integration ran but entity not in catalog',
                description: 'Common causes when entities fail to appear.',
                code: `# 1. Check integration logs in Port UI
#    Settings ‚Üí Integrations ‚Üí [Your Integration] ‚Üí Logs

# 2. Verify mapping selector matches
selector:
  query: 'true'  # Shows all - then narrow down

# 3. Check identifier is valid (no special chars)
identifier: .metadata.name | gsub("[^a-zA-Z0-9-_]"; "-")

# 4. Verify blueprint exists
curl "https://api.getport.io/v1/blueprints/YOUR_BLUEPRINT" \\
  -H "Authorization: Bearer $TOKEN"

# 5. Check required properties are mapped
# Missing required props = silent failure

# 6. Test JQ mapping locally
echo '{"metadata":{"name":"test"}}' | jq '.metadata.name'`,
                output: 'Checklist for debugging missing entities',
                tags: ['troubleshooting', 'entity', 'missing', 'debug']
            },
            {
                id: 'ts-jq-returning-null',
                validated: 'adapt',
                category: 'troubleshooting',
                title: 'JQ Returning Null',
                problem: 'Mapping produces null values',
                description: 'Debug JQ expressions that return unexpected nulls.',
                code: `# Problem: Property shows null in Port

# 1. Test the raw data
echo '$YOUR_JSON' | jq '.path.to.property'

# 2. Add debug output in mapping (temporary)
properties:
  debug_raw: ". | tostring"  # See full object

# 3. Common fixes:

# Missing field - add default
.properties.owner // "unassigned"

# Nested null - use try
try .deep.nested.value catch "default"

# Array might be empty
.containers[0].image // "no-containers"

# Wrong type - check with type
if (.value | type) == "string" then .value else (.value | tostring) end

# 4. Test in Port UI
# Catalog ‚Üí Entity ‚Üí "Raw" tab shows actual data`,
                output: 'JQ debugging techniques',
                tags: ['troubleshooting', 'jq', 'null', 'debug']
            },
            {
                id: 'ts-relation-not-resolving',
                validated: 'adapt',
                category: 'troubleshooting',
                title: 'Relation Not Resolving',
                problem: 'Relation shows unresolved or missing target',
                description: 'Fix broken entity relations.',
                code: `# 1. Verify target entity exists
curl "https://api.getport.io/v1/blueprints/TARGET_BP/entities/TARGET_ID" \\
  -H "Authorization: Bearer $TOKEN"

# 2. Check relation definition matches
# In blueprint:
"relations": {
  "team": {
    "target": "team",     # Must match target blueprint identifier
    "required": false,    # If true, entity fails without valid relation
    "many": false
  }
}

# 3. Check mapping returns valid identifier
relations:
  team: .metadata.labels.team  # Must match existing entity identifier

# 4. For search-based relations, verify query syntax
relations:
  service:
    combinator: '"and"'  # Note: quoted string
    rules:
      - property: '"identifier"'  # Note: quoted
        operator: '"="'
        value: .metadata.labels.app

# 5. Check target blueprint allows this relation (if restricted)`,
                output: 'Relation debugging steps',
                tags: ['troubleshooting', 'relation', 'unresolved', 'debug']
            },
            {
                id: 'ts-action-run-stuck',
                validated: 'adapt',
                category: 'troubleshooting',
                title: 'Action Run Stuck',
                problem: 'Action shows IN_PROGRESS forever',
                description: 'Debug actions that never complete.',
                code: `# 1. Check GitHub Action workflow ran
# GitHub ‚Üí Actions ‚Üí Look for recent runs

# 2. Verify workflow receives Port run ID
# The run ID must be passed as input to your workflow

# 3. Ensure status update runs even on failure
# In your GitHub workflow:
- name: Report to Port
  if: always()  # CRITICAL: runs even if previous steps failed
  run: |
    curl -X PATCH "https://api.getport.io/v1/actions/runs/$PORT_RUN_ID" \\
      -H "Authorization: Bearer $TOKEN" \\
      -H "Content-Type: application/json" \\
      -d '{"status": "SUCCESS"}'  # or FAILURE based on job result

# 4. Manually complete stuck run
curl -X PATCH "https://api.getport.io/v1/actions/runs/RUN_ID" \\
  -H "Authorization: Bearer $TOKEN" \\
  -H "Content-Type: application/json" \\
  -d '{"status":"FAILURE","summary":"Manually terminated"}'`,
                output: 'Action debugging and manual completion',
                tags: ['troubleshooting', 'action', 'stuck', 'github']
            }
        ];

        // Precompute search blobs for faster filtering
        patterns.forEach(p => {
            p._search = [
                p.title,
                p.problem || '',
                p.description,
                p.code,
                p.output || '',
                p.tags.join(' ')
            ].join(' ').toLowerCase();
        });

        let activeCategory = 'all';
        let searchTerm = '';
        let debounceTimer = null;

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function copyToClipboard(text, btn, successText = 'Copied!', originalText = 'Copy') {
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text).then(() => {
                    btn.textContent = successText;
                    btn.classList.add('copied');
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.classList.remove('copied');
                    }, 2000);
                });
            } else {
                const textarea = document.createElement('textarea');
                textarea.value = text;
                textarea.setAttribute('readonly', '');
                textarea.style.position = 'absolute';
                textarea.style.left = '-9999px';
                document.body.appendChild(textarea);
                textarea.select();
                textarea.setSelectionRange(0, textarea.value.length);
                document.execCommand('copy');
                document.body.removeChild(textarea);
                btn.textContent = successText;
                btn.classList.add('copied');
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.classList.remove('copied');
                }, 2000);
            }
        }

        function filterPatterns() {
            const term = searchTerm.toLowerCase().trim();
            return patterns.filter(p => {
                const categoryMatch = activeCategory === 'all' || p.category === activeCategory;
                if (!categoryMatch) return false;
                if (!term) return true;
                return p._search.includes(term);
            });
        }

        function renderPatterns() {
            const grid = document.getElementById('patternGrid');
            const status = document.getElementById('status');
            const filtered = filterPatterns();

            if (filtered.length === 0) {
                grid.innerHTML = '';
                status.textContent = 'No patterns found. Try a different search or category.';
                status.style.display = 'block';
                return;
            }

            status.textContent = `Showing ${filtered.length} of ${patterns.length} patterns`;
            status.style.display = 'block';

            grid.innerHTML = filtered.map(p => {
                const validValues = ['production', 'tested', 'adapt'];
                const validation = validValues.includes(p.validated) ? p.validated : (console.warn(`Unknown validation "${p.validated}" for ${p.id}`), 'adapt');
                const badgeClass = validation === 'production' ? 'validation-production' : 
                                   validation === 'tested' ? 'validation-tested' : 'validation-adapt';
                const badgeIcon = validation === 'production' ? '‚úÖ' : 
                                  validation === 'tested' ? 'üß™' : '‚öôÔ∏è';
                const badgeText = validation === 'production' ? 'Production' : 
                                  validation === 'tested' ? 'Tested' : 'Adapt';
                const categoryDisplay = p.category === 'jq' ? 'JQ' : 
                                        p.category.charAt(0).toUpperCase() + p.category.slice(1);
                return `
                <div class="pattern-card" id="${p.id}">
                    <div class="card-header">
                        <div class="card-meta-row">
                            <span class="card-category cat-${p.category}">${categoryDisplay}</span>
                            <span class="validation-badge ${badgeClass}">${badgeIcon} ${badgeText}</span>
                        </div>
                        <div class="card-title-row">
                            <h3 class="card-title">${escapeHtml(p.title)}</h3>
                            <button class="link-btn" data-id="${p.id}" aria-label="Copy link to ${escapeHtml(p.title)} pattern" title="Copy link">üîó</button>
                        </div>
                        ${p.problem ? `<p class="card-problem">üí° ${escapeHtml(p.problem)}</p>` : ''}
                        <p class="card-description">${escapeHtml(p.description)}</p>
                    </div>
                    <div class="card-body">
                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-label">Code</span>
                                <button class="copy-btn" data-id="${p.id}" aria-label="Copy ${escapeHtml(p.title)} code snippet">Copy</button>
                            </div>
                            <pre>${escapeHtml(p.code)}</pre>
                        </div>
                        ${p.output ? `
                        <div class="output-block">
                            <div class="output-label">Output / Notes</div>
                            <div class="output-content">${escapeHtml(p.output)}</div>
                        </div>
                        ` : ''}
                    </div>
                    <div class="card-tags">
                        ${p.tags.map(t => `<span class="tag">${escapeHtml(t)}</span>`).join('')}
                    </div>
                </div>
            `}).join('');

            // Attach copy code handlers
            grid.querySelectorAll('.copy-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const patternId = this.getAttribute('data-id');
                    const pattern = patterns.find(p => p.id === patternId);
                    if (pattern) {
                        copyToClipboard(pattern.code, this, 'Copied!', 'Copy');
                    }
                });
            });

            // Attach copy link handlers
            grid.querySelectorAll('.link-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const patternId = this.getAttribute('data-id');
                    const url = `${window.location.origin}${window.location.pathname}#${patternId}`;
                    copyToClipboard(url, this, '‚úì', 'üîó');
                });
            });
        }

        // Debounced search
        document.getElementById('searchBox').addEventListener('input', (e) => {
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(() => {
                searchTerm = e.target.value;
                renderPatterns();
            }, 150);
        });

        // Category filters
        document.querySelectorAll('.category-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.category-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                activeCategory = btn.dataset.category;
                renderPatterns();
            });
        });

        // Handle deep links on page load
        function handleDeepLink() {
            if (window.location.hash) {
                const id = window.location.hash.slice(1);
                const element = document.getElementById(id);
                if (element) {
                    setTimeout(() => {
                        element.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }, 100);
                }
            }
        }

        // Initial render
        renderPatterns();
        handleDeepLink();

        // Handle hash changes
        window.addEventListener('hashchange', handleDeepLink);
    </script>
</body>
</html>
