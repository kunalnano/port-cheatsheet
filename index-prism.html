<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Port.io Implementation Cheat Sheet (Prism)</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(to bottom right, #f0f9ff, #e0e7ff);
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: linear-gradient(135deg, #10b981, #3b82f6);
            color: white;
            padding: 40px;
            border-radius: 12px;
            margin-bottom: 20px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.95;
            font-size: 1.1em;
        }

        .header-actions {
            margin-top: 15px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .header-btn {
            background: rgba(255,255,255,0.2);
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            text-decoration: none;
            transition: background 0.3s;
        }

        .header-btn:hover {
            background: rgba(255,255,255,0.3);
        }

        .notice-box {
            background: #fef3c7;
            border-left: 4px solid #f59e0b;
            padding: 15px 20px;
            margin-bottom: 20px;
            border-radius: 0 8px 8px 0;
            font-size: 14px;
            color: #92400e;
        }

        .notice-box strong {
            color: #78350f;
        }

        .notice-box code {
            background: #fde68a;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 13px;
        }

        .controls {
            background: white;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .search-box {
            width: 100%;
            padding: 12px 20px;
            font-size: 16px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            margin-bottom: 15px;
            transition: border-color 0.3s;
        }

        .search-box:focus {
            outline: none;
            border-color: #3b82f6;
        }

        .category-filters {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .category-btn {
            padding: 8px 16px;
            border: 2px solid #e5e7eb;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
        }

        .category-btn:hover {
            background: #f3f4f6;
        }

        .category-btn.active {
            background: #3b82f6;
            color: white;
            border-color: #3b82f6;
        }

        .pattern-grid {
            display: grid;
            gap: 25px;
        }

        .pattern-card {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            transition: transform 0.3s, box-shadow 0.3s;
        }

        .pattern-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 15px rgba(0, 0, 0, 0.15);
        }

        .pattern-header {
            padding: 20px;
            border-bottom: 1px solid #e5e7eb;
        }

        .pattern-title {
            font-size: 1.3em;
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 8px;
        }

        .pattern-problem {
            color: #059669;
            font-weight: 500;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .pattern-description {
            color: #6b7280;
            margin-bottom: 12px;
        }

        .tags {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .tag {
            padding: 4px 10px;
            background: #dbeafe;
            color: #1e40af;
            border-radius: 12px;
            font-size: 12px;
        }

        .code-section {
            border-bottom: 1px solid #374151;
        }

        .code-section:last-child {
            border-bottom: none;
        }

        .code-label {
            background: #374151;
            color: #9ca3af;
            padding: 8px 20px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .code-container {
            position: relative;
            background: #1e293b;
            padding: 0;
        }

        .copy-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #374151;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.3s;
            z-index: 10;
        }

        .copy-btn:hover {
            background: #4b5563;
        }

        .copy-btn.copied {
            background: #10b981;
        }

        pre {
            padding: 20px;
            overflow-x: auto;
            margin: 0;
            background: #1e293b !important;
        }

        pre[class*="language-"] {
            margin: 0;
            padding: 20px;
            background: #1e293b !important;
        }

        code {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 13px;
            line-height: 1.5;
            white-space: pre;
        }

        code[class*="language-"] {
            text-shadow: none !important;
        }

        .output-section {
            background: #064e3b;
        }

        .output-section .code-label {
            background: #065f46;
            color: #6ee7b7;
        }

        .output-section code {
            color: #a7f3d0;
        }

        .status {
            text-align: center;
            padding: 10px;
            background: #f3f4f6;
            color: #6b7280;
            font-size: 14px;
            margin-bottom: 20px;
            border-radius: 8px;
        }

        .footer {
            text-align: center;
            padding: 30px;
            color: #6b7280;
            margin-top: 50px;
        }

        .footer a {
            color: #3b82f6;
            text-decoration: none;
        }

        .footer a:hover {
            text-decoration: underline;
        }

        .no-results {
            text-align: center;
            padding: 60px;
            color: #6b7280;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 1.8em;
            }
            .category-filters {
                display: grid;
                grid-template-columns: repeat(2, 1fr);
            }
        }

        /* Print styles */
        @media print {
            body {
                background: white;
                font-size: 11px;
            }
            .container {
                max-width: 100%;
                padding: 10px;
            }
            .header {
                background: #1f2937 !important;
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
                padding: 20px;
                margin-bottom: 15px;
            }
            .header-actions, .controls, .notice-box, .status, .copy-btn {
                display: none !important;
            }
            .pattern-card {
                break-inside: avoid;
                box-shadow: none;
                border: 1px solid #e5e7eb;
                margin-bottom: 15px;
            }
            .pattern-grid {
                gap: 15px;
            }
            .code-container, .output-section {
                background: #f3f4f6 !important;
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
            }
            code {
                color: #1f2937 !important;
                font-size: 10px;
            }
            .code-label {
                background: #e5e7eb !important;
                color: #374151 !important;
            }
            pre {
                padding: 10px;
            }
            .footer {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ Port.io Implementation Cheat Sheet</h1>
            <p>Copy-paste patterns for blueprints, mappings, actions, and automations</p>
            <div class="header-actions">
                <button class="header-btn" onclick="window.print()">üñ®Ô∏è Print / Save PDF</button>
                <a class="header-btn" href="https://docs.port.io" target="_blank">üìö Full Docs</a>
            </div>
        </div>

        <div class="notice-box">
            <strong>üìù Placeholders:</strong> Replace <code>&lt;YOUR_ORG&gt;</code>, <code>&lt;YOUR_REPO&gt;</code>, <code>&lt;YOUR_DOMAIN&gt;</code> with your values.
            <strong>API Region:</strong> US ‚Üí <code>api.getport.io</code> | EU ‚Üí <code>api.eu.getport.io</code>
        </div>

        <div class="controls">
            <input type="text" class="search-box" id="searchBox" placeholder="Search patterns (e.g., 'kubernetes', 'jq time', 'webhook')...">
            <div class="category-filters">
                <button class="category-btn active" data-category="all">All</button>
                <button class="category-btn" data-category="blueprints">Blueprints</button>
                <button class="category-btn" data-category="mapping">Mapping</button>
                <button class="category-btn" data-category="actions">Actions</button>
                <button class="category-btn" data-category="scorecards">Scorecards</button>
                <button class="category-btn" data-category="automations">Automations</button>
                <button class="category-btn" data-category="jq">JQ</button>
                <button class="category-btn" data-category="api">API</button>
            </div>
        </div>

        <div class="status" id="status">Loading patterns...</div>

        <div class="pattern-grid" id="patternGrid"></div>

        <div class="footer">
            üí° Click copy to grab snippets ‚Ä¢ <a href="https://docs.port.io" target="_blank">docs.port.io</a> for full documentation
            ‚Ä¢ Built for Port.io implementations
        </div>
    </div>

    <script>
        const patterns = [
            // ==================== BLUEPRINTS ====================
            {
                category: 'blueprints',
                title: 'Basic Blueprint',
                problem: 'Need to model a service/resource in Port',
                description: 'Standard blueprint with string, number, boolean, and enum properties plus a required relation.',
                code: `{
  "identifier": "service",
  "title": "Service",
  "icon": "Service",
  "schema": {
    "properties": {
      "language": {
        "type": "string",
        "title": "Language",
        "enum": ["Python", "Go", "Node.js", "Java"],
        "enumColors": {
          "Python": "blue",
          "Go": "turquoise",
          "Node.js": "green",
          "Java": "orange"
        }
      },
      "owner": {
        "type": "string",
        "title": "Owner",
        "format": "user"
      },
      "slack_channel": {
        "type": "string",
        "title": "Slack Channel",
        "pattern": "^#[a-z0-9-]+$"
      },
      "tier": {
        "type": "number",
        "title": "Tier",
        "enum": [1, 2, 3],
        "default": 3
      },
      "on_call": {
        "type": "boolean",
        "title": "Has On-Call",
        "default": false
      }
    },
    "required": ["language", "owner"]
  },
  "relations": {
    "domain": {
      "title": "Domain",
      "target": "domain",
      "required": true,
      "many": false
    }
  }
}`,
                output: `Blueprint "service" created with:
- 5 properties (language, owner, slack_channel, tier, on_call)
- 1 required relation to "domain"
- Appears in catalog at: Service`,
                tags: ['blueprint', 'properties', 'relations', 'enum']
            },
            {
                category: 'blueprints',
                title: 'Array & Object Properties',
                problem: 'Need to store lists (tags, endpoints) or nested data',
                description: 'Array properties with typed items and object properties for structured nested data.',
                code: `{
  "schema": {
    "properties": {
      "tags": {
        "type": "array",
        "title": "Tags",
        "items": { "type": "string" },
        "default": []
      },
      "endpoints": {
        "type": "array",
        "title": "API Endpoints",
        "items": {
          "type": "object",
          "properties": {
            "path": { "type": "string" },
            "method": { "type": "string", "enum": ["GET", "POST", "PUT", "DELETE"] }
          }
        }
      },
      "config": {
        "type": "object",
        "title": "Configuration",
        "description": "Free-form JSON config"
      },
      "links": {
        "type": "object",
        "title": "Links",
        "properties": {
          "repo": { "type": "string", "format": "url" },
          "docs": { "type": "string", "format": "url" },
          "dashboard": { "type": "string", "format": "url" }
        }
      }
    }
  }
}`,
                output: `Properties accept:
- tags: ["backend", "critical", "python"]
- endpoints: [{"path": "/api/users", "method": "GET"}]
- config: {"timeout": 30, "retries": 3}
- links: {"repo": "https://...", "docs": "https://..."}`,
                tags: ['blueprint', 'array', 'object', 'nested']
            },
            {
                category: 'blueprints',
                title: 'Mirror Properties',
                problem: 'Need to display data from a related entity without duplication',
                description: 'Pull properties from related entities. Supports multi-hop paths through relation chains.',
                code: `{
  "mirrorProperties": {
    "domain_owner": {
      "title": "Domain Owner",
      "path": "domain.owner"
    },
    "team_slack": {
      "title": "Team Slack Channel",
      "path": "domain.owning_team.slack_channel"
    },
    "cluster_region": {
      "title": "Cluster Region",
      "path": "environment.cluster.region"
    }
  }
}`,
                output: `Entity displays:
- Domain Owner: "alice@company.com" (from related domain)
- Team Slack Channel: "#platform-team" (2-hop: domain ‚Üí team)
- Cluster Region: "us-east-1" (2-hop: environment ‚Üí cluster)

Values update automatically when source changes.`,
                tags: ['mirror', 'relations', 'properties', 'derived']
            },
            {
                category: 'blueprints',
                title: 'Calculation Properties',
                problem: 'Need computed fields (URLs, scores, flags) derived from entity data',
                description: 'JQ expressions that compute values from entity properties. Evaluated on every view.',
                code: `{
  "calculationProperties": {
    "service_url": {
      "title": "Service URL",
      "type": "string",
      "format": "url",
      "calculation": "\"https://\" + .identifier + \".prod.company.com\""
    },
    "is_critical": {
      "title": "Is Critical",
      "type": "boolean",
      "calculation": ".properties.tier == 1 or .properties.pagerduty_enabled == true"
    },
    "health_score": {
      "title": "Health Score",
      "type": "number",
      "calculation": "((.properties.uptime // 0) * 0.4 + (.properties.test_coverage // 0) * 0.3 + (.properties.doc_coverage // 0) * 0.3) | floor"
    },
    "days_since_deploy": {
      "title": "Days Since Deploy",
      "type": "number",
      "calculation": "if .properties.last_deployed then ((now - (.properties.last_deployed | fromdateiso8601)) / 86400) | floor else null end"
    },
    "status_emoji": {
      "title": "Status",
      "type": "string",
      "calculation": "if .properties.status == \"healthy\" then \"‚úÖ\" elif .properties.status == \"degraded\" then \"‚ö†Ô∏è\" else \"‚ùå\" end"
    }
  }
}`,
                output: `Calculated values:
- service_url: "https://checkout-api.prod.company.com"
- is_critical: true
- health_score: 87
- days_since_deploy: 12
- status_emoji: "‚úÖ"`,
                tags: ['calculation', 'jq', 'computed', 'derived']
            },
            {
                category: 'blueprints',
                title: 'Aggregation Properties',
                problem: 'Need metrics from child entities (counts, averages, sums)',
                description: 'Calculate aggregate values from related entities. Updates automatically as children change.',
                code: `{
  "aggregationProperties": {
    "service_count": {
      "title": "Number of Services",
      "type": "number",
      "target": "service",
      "query": {
        "combinator": "and",
        "rules": [{ "property": "$relation.domain", "operator": "=", "value": "{{identifier}}" }]
      },
      "calculationSpec": {
        "calculationBy": "entities",
        "func": "count"
      }
    },
    "critical_issues": {
      "title": "Critical Issues",
      "type": "number",
      "target": "jira_issue",
      "query": {
        "combinator": "and",
        "rules": [
          { "property": "service", "operator": "=", "value": "{{identifier}}" },
          { "property": "priority", "operator": "=", "value": "Critical" },
          { "property": "status", "operator": "!=", "value": "Done" }
        ]
      },
      "calculationSpec": {
        "calculationBy": "entities",
        "func": "count"
      }
    },
    "avg_response_time": {
      "title": "Avg Response Time (ms)",
      "type": "number",
      "target": "api_endpoint",
      "query": {
        "combinator": "and",
        "rules": [{ "property": "service", "operator": "=", "value": "{{identifier}}" }]
      },
      "calculationSpec": {
        "calculationBy": "property",
        "property": "p99_latency",
        "func": "average"
      }
    }
  }
}`,
                output: `Aggregated values on domain entity:
- service_count: 24
- critical_issues: 3
- avg_response_time: 145.7

Funcs: count, sum, average, min, max`,
                tags: ['aggregation', 'metrics', 'count', 'rollup']
            },

            // ==================== MAPPING ====================
            {
                category: 'mapping',
                title: 'GitHub Repository Mapping',
                problem: 'Sync GitHub repos to Port catalog',
                description: 'Map repositories with language normalization, topic-based relations, and team ownership.',
                code: `resources:
  - kind: repository
    selector:
      query: '.archived == false and .name | startswith("svc-")'
    port:
      entity:
        mappings:
          identifier: .name
          title: '.name | split("-")[1:] | join("-") | gsub("_"; " ") | ascii_upcase[0:1] + .[1:]'
          blueprint: '"service"'
          properties:
            url: .html_url
            description: .description
            language: |
              if .language == "JavaScript" or .language == "TypeScript" then "Node.js"
              elif .language == null then "Unknown"
              else .language
              end
            default_branch: .default_branch
            is_private: .private
            created_at: .created_at
            topics: .topics
          relations:
            domain: '.topics[] | select(startswith("domain-")) | split("-")[1]'
            team: '.topics[] | select(startswith("team-")) | split("-")[1]'`,
                output: `Repo "svc-checkout-api" with topics ["domain-payments", "team-platform"] creates:
{
  "identifier": "svc-checkout-api",
  "title": "Checkout Api",
  "properties": {
    "language": "Node.js",
    "topics": ["domain-payments", "team-platform"]
  },
  "relations": {
    "domain": "payments",
    "team": "platform"
  }
}`,
                tags: ['mapping', 'github', 'repository', 'integration']
            },
            {
                category: 'mapping',
                title: 'Kubernetes Deployment Mapping',
                problem: 'Sync K8s Deployments with resource details and status',
                description: 'Map deployments with container info, resource limits, and rolling update status.',
                code: `resources:
  - kind: deployment
    selector:
      query: '.metadata.namespace != "kube-system"'
    port:
      entity:
        mappings:
          identifier: '.metadata.namespace + "-" + .metadata.name'
          title: .metadata.name
          blueprint: '"workload"'
          properties:
            namespace: .metadata.namespace
            replicas: .spec.replicas
            available_replicas: .status.availableReplicas // 0
            image: .spec.template.spec.containers[0].image
            image_tag: '.spec.template.spec.containers[0].image | split(":")[1] // "latest"'
            cpu_request: '.spec.template.spec.containers[0].resources.requests.cpu // "not set"'
            memory_request: '.spec.template.spec.containers[0].resources.requests.memory // "not set"'
            labels: .metadata.labels
            strategy: .spec.strategy.type
            created_at: .metadata.creationTimestamp
          relations:
            service: '.metadata.labels["app.kubernetes.io/name"] // .metadata.labels.app // .metadata.name'
            namespace: .metadata.namespace
            cluster: '"{{portalConfig.exporter.cluster_name}}"'`,
                output: `Deployment creates workload entity:
{
  "identifier": "production-checkout-api",
  "title": "checkout-api",
  "properties": {
    "namespace": "production",
    "replicas": 3,
    "available_replicas": 3,
    "image": "ghcr.io/company/checkout:v1.2.3",
    "image_tag": "v1.2.3",
    "cpu_request": "100m",
    "memory_request": "256Mi"
  }
}`,
                tags: ['mapping', 'kubernetes', 'deployment', 'k8s']
            },
            {
                category: 'mapping',
                title: 'ArgoCD Application Mapping',
                problem: 'Sync ArgoCD apps with sync status and GitOps metadata',
                description: 'Map ArgoCD applications with health, sync status, and source repository info.',
                code: `resources:
  - kind: application
    selector:
      query: 'true'
    port:
      entity:
        mappings:
          identifier: .metadata.name
          title: .metadata.name
          blueprint: '"argocd_app"'
          properties:
            sync_status: .status.sync.status
            health_status: .status.health.status
            sync_message: '.status.operationState.message // ""'
            repo_url: .spec.source.repoURL
            path: .spec.source.path
            target_revision: .spec.source.targetRevision
            destination_namespace: .spec.destination.namespace
            destination_server: .spec.destination.server
            auto_sync: .spec.syncPolicy.automated != null
            last_synced_at: .status.operationState.finishedAt
            created_at: .metadata.creationTimestamp
          relations:
            service: '.metadata.name | split("-") | .[:-1] | join("-")'
            environment: '.metadata.name | split("-") | .[-1]'
            cluster: '.spec.destination.name // (.spec.destination.server | split("/")[-1])'`,
                output: `ArgoCD app "checkout-api-prod" creates:
{
  "identifier": "checkout-api-prod",
  "properties": {
    "sync_status": "Synced",
    "health_status": "Healthy",
    "auto_sync": true,
    "target_revision": "main"
  },
  "relations": {
    "service": "checkout-api",
    "environment": "prod"
  }
}`,
                tags: ['mapping', 'argocd', 'gitops', 'kubernetes']
            },
            {
                category: 'mapping',
                title: 'Search-Based Relations',
                problem: 'Relate entities when identifier doesn\'t match directly',
                description: 'Use search queries to find related entities by property matching.',
                code: `relations:
  # Find owner by matching github username to team member property
  owner:
    combinator: "and"
    rules:
      - property: "github_username"
        operator: "="
        value: .owner.login

  # Find environment by partial name match
  environment:
    combinator: "and"
    rules:
      - property: "name"
        operator: "contains"
        value: .metadata.labels.environment

  # Find all services in same namespace (many relation)
  sibling_services:
    combinator: "and"
    rules:
      - property: "namespace"
        operator: "="
        value: .metadata.namespace
      - property: "$identifier"
        operator: "!="
        value: .metadata.name`,
                output: `Search-based relation finds entities where:
- owner: team_member.github_username == "octocat"
- environment: environment.name contains "production"
- sibling_services: all services in same namespace except self`,
                tags: ['mapping', 'relations', 'search', 'query']
            },
            {
                category: 'mapping',
                title: 'Terraform State Mapping',
                problem: 'Sync Terraform-managed cloud resources to Port',
                description: 'Extract resources from Terraform state with module paths and dependencies.',
                code: `resources:
  - kind: tfstate
    selector:
      query: '.values.root_module.resources != null'
    port:
      itemsToParse: .values.root_module.resources
      entity:
        mappings:
          identifier: .item.address | gsub("[.\\\\[\\\\]]"; "-")
          title: .item.name
          blueprint: '"cloud_resource"'
          properties:
            resource_type: .item.type
            provider: .item.provider_name
            mode: .item.mode
            address: .item.address
            # Extract common attributes based on resource type
            arn: .item.values.arn // .item.values.id
            region: .item.values.region // .item.values.availability_zone
            tags: .item.values.tags // {}
          relations:
            # Relate to service based on tags
            service: .item.values.tags.service // .item.values.tags.Service
            environment: .item.values.tags.environment // .item.values.tags.Environment`,
                output: `Terraform resource "aws_rds_instance.main" creates:
{
  "identifier": "aws_rds_instance-main",
  "title": "main",
  "properties": {
    "resource_type": "aws_rds_instance",
    "provider": "aws",
    "arn": "arn:aws:rds:us-east-1:123456789:db:main"
  },
  "relations": {
    "service": "checkout-api",
    "environment": "production"
  }
}`,
                tags: ['mapping', 'terraform', 'iac', 'aws', 'cloud']
            },
            {
                category: 'mapping',
                title: 'Generic Webhook (PagerDuty/Sentry)',
                problem: 'Ingest events from tools without native integration',
                description: 'Map raw JSON payloads from any webhook source to entities.',
                code: `resources:
  - kind: pagerduty_incident
    selector:
      query: 'true'
    port:
      entity:
        mappings:
          identifier: .body.incident.id
          title: .body.incident.title
          blueprint: '"incident"'
          properties:
            status: .body.incident.status
            urgency: .body.incident.urgency
            created_at: .body.incident.created_at
            # Extract service ID from nested object
            service_id: .body.incident.service.id
            # Map arbitrary headers if needed
            source: .headers["x-webhook-source"]
          relations:
            # Relate to service by looking up the PD Service ID
            service:
              combinator: "and"
              rules:
                - property: "pagerduty_service_id"
                  operator: "="
                  value: .body.incident.service.id`,
                output: `Maps any incoming JSON body.
Key concepts:
- Access payload via .body
- Access headers via .headers
- Use search relation to link by property match

Works for: PagerDuty, Sentry, Datadog, custom webhooks`,
                tags: ['mapping', 'webhook', 'json', 'pagerduty', 'generic']
            },

            // ==================== ACTIONS ====================
            {
                category: 'actions',
                title: 'Basic Self-Service Action',
                problem: 'Let developers trigger a deployment workflow',
                description: 'Action with environment selector and version input, triggers GitHub workflow.',
                code: `{
  "identifier": "deploy_service",
  "title": "üöÄ Deploy Service",
  "icon": "Deployment",
  "trigger": {
    "type": "self-service",
    "blueprintIdentifier": "service",
    "operation": "DAY-2",
    "userInputs": {
      "properties": {
        "environment": {
          "type": "string",
          "title": "Environment",
          "enum": ["dev", "staging", "prod"],
          "enumColors": {
            "dev": "turquoise",
            "staging": "yellow",
            "prod": "red"
          },
          "default": "dev"
        },
        "version": {
          "type": "string",
          "title": "Version",
          "description": "Semver tag (e.g., v1.2.3)",
          "pattern": "^v[0-9]+\\\\.[0-9]+\\\\.[0-9]+(-[a-zA-Z0-9]+)?$"
        },
        "dry_run": {
          "type": "boolean",
          "title": "Dry Run",
          "description": "Simulate without deploying",
          "default": false
        }
      },
      "required": ["environment", "version"]
    }
  },
  "invocationMethod": {
    "type": "GITHUB",
    "org": "<YOUR_ORG>",
    "repo": "<YOUR_REPO>",
    "workflow": "deploy.yml",
    "workflowInputs": {
      "service": "{{.entity.identifier}}",
      "environment": "{{.inputs.environment}}",
      "version": "{{.inputs.version}}",
      "dry_run": "{{.inputs.dry_run}}",
      "port_run_id": "{{.run.id}}",
      "triggered_by": "{{.trigger.by.user.email}}"
    }
  }
}`,
                output: `Action appears as "üöÄ Deploy Service" button on service entities.
User selects environment, enters version ‚Üí triggers deploy.yml with inputs.
Port tracks run status until workflow reports back.`,
                tags: ['action', 'self-service', 'github', 'deployment']
            },
            {
                category: 'actions',
                title: 'Action with Dynamic Entity Selection',
                problem: 'Need dropdown that lists entities from another blueprint',
                description: 'Input that lets user select from existing entities, with optional filtering.',
                code: `{
  "identifier": "link_service_to_cluster",
  "title": "Link to Cluster",
  "trigger": {
    "type": "self-service",
    "blueprintIdentifier": "service",
    "userInputs": {
      "properties": {
        "target_cluster": {
          "type": "string",
          "title": "Target Cluster",
          "format": "entity",
          "blueprint": "cluster",
          "description": "Select destination cluster"
        },
        "namespace": {
          "type": "string",
          "title": "Namespace",
          "format": "entity",
          "blueprint": "namespace",
          "dataset": {
            "combinator": "and",
            "rules": [
              {
                "property": "$relation.cluster",
                "operator": "=",
                "value": "{{.inputs.target_cluster}}"
              }
            ]
          },
          "dependsOn": ["target_cluster"]
        }
      },
      "required": ["target_cluster", "namespace"]
    }
  },
  "invocationMethod": {
    "type": "WEBHOOK",
    "url": "https://<YOUR_DOMAIN>/api/link-cluster"
  }
}`,
                output: `Action UI shows:
1. "Target Cluster" dropdown ‚Üí lists all cluster entities
2. "Namespace" dropdown ‚Üí filters to show only namespaces 
   related to selected cluster (via dependsOn + dataset)`,
                tags: ['action', 'entity-selection', 'dynamic', 'dependent-inputs']
            },
            {
                category: 'actions',
                title: 'Create Entity Action',
                problem: 'Scaffold a new service from scratch',
                description: 'Action not tied to existing entity, creates new entity on completion.',
                code: `{
  "identifier": "scaffold_service",
  "title": "üÜï Create New Service",
  "icon": "Plus",
  "trigger": {
    "type": "self-service",
    "operation": "CREATE",
    "blueprintIdentifier": "service",
    "userInputs": {
      "properties": {
        "name": {
          "type": "string",
          "title": "Service Name",
          "pattern": "^[a-z][a-z0-9-]{2,30}$",
          "description": "Lowercase, alphanumeric, hyphens only"
        },
        "language": {
          "type": "string",
          "title": "Language",
          "enum": ["python", "go", "nodejs", "java"]
        },
        "template": {
          "type": "string",
          "title": "Template",
          "enum": ["basic-api", "graphql-api", "worker", "cron-job"],
          "default": "basic-api"
        },
        "domain": {
          "type": "string",
          "title": "Domain",
          "format": "entity",
          "blueprint": "domain"
        }
      },
      "required": ["name", "language", "domain"]
    }
  },
  "invocationMethod": {
    "type": "GITHUB",
    "org": "<YOUR_ORG>",
    "repo": "service-scaffolder",
    "workflow": "scaffold.yml",
    "workflowInputs": {
      "service_name": "{{.inputs.name}}",
      "language": "{{.inputs.language}}",
      "template": "{{.inputs.template}}",
      "domain": "{{.inputs.domain.identifier}}",
      "owner_email": "{{.trigger.by.user.email}}",
      "port_run_id": "{{.run.id}}"
    }
  }
}`,
                output: `Action available from "Service" catalog page (not on specific entity).
Workflow scaffolds repo, then upserts entity:
POST /blueprints/service/entities?upsert=true
{
  "identifier": "my-new-service",
  "properties": { "language": "python", ... },
  "relations": { "domain": "payments" }
}`,
                tags: ['action', 'create', 'scaffold', 'day-0']
            },
            {
                category: 'actions',
                title: 'Action with Approval',
                problem: 'Require approval before production changes',
                description: 'Gate dangerous actions behind team approval with conditions.',
                code: `{
  "identifier": "delete_service",
  "title": "üóëÔ∏è Delete Service",
  "icon": "Trash",
  "trigger": {
    "type": "self-service",
    "blueprintIdentifier": "service",
    "operation": "DELETE",
    "userInputs": {
      "properties": {
        "confirm_name": {
          "type": "string",
          "title": "Type service name to confirm",
          "description": "Must match exactly"
        },
        "reason": {
          "type": "string",
          "title": "Reason for deletion",
          "format": "markdown"
        }
      },
      "required": ["confirm_name", "reason"]
    },
    "condition": {
      "type": "JQ",
      "expressions": [".inputs.confirm_name == .entity.identifier"],
      "combinator": "and"
    }
  },
  "requiredApproval": {
    "type": "ANY",
    "approvers": {
      "users": [],
      "teams": ["platform-admins", "{{.entity.properties.owning_team}}"]
    }
  },
  "invocationMethod": {
    "type": "GITHUB",
    "org": "<YOUR_ORG>",
    "repo": "service-lifecycle",
    "workflow": "delete-service.yml"
  }
}`,
                output: `Flow:
1. User fills form, must type service name correctly (condition validates)
2. Request goes to pending approval
3. Platform admin OR owning team member approves
4. Workflow executes deletion`,
                tags: ['action', 'approval', 'rbac', 'delete', 'dangerous']
            },
            {
                category: 'actions',
                title: 'GitHub Workflow with Status Reporting',
                problem: 'Keep Port run status in sync with workflow progress',
                description: 'Complete workflow pattern with progress updates, success/failure handling, and links.',
                code: `name: Deploy Service
on:
  workflow_dispatch:
    inputs:
      service:
        required: true
      environment:
        required: true
      version:
        required: true
      port_run_id:
        required: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Inform Port - Starting
        uses: port-labs/port-github-action@v1
        with:
          clientId: \${{ secrets.PORT_CLIENT_ID }}
          clientSecret: \${{ secrets.PORT_CLIENT_SECRET }}
          operation: PATCH_RUN
          runId: \${{ inputs.port_run_id }}
          status: RUNNING
          logMessage: |
            üöÄ Starting deployment
            Service: \${{ inputs.service }}
            Version: \${{ inputs.version }}
            Environment: \${{ inputs.environment }}

      - name: Deploy
        id: deploy
        run: |
          # Your deployment logic here
          echo "Deploying \${{ inputs.service }} version \${{ inputs.version }}"
          kubectl set image deployment/\${{ inputs.service }} \\
            app=ghcr.io/\${{ github.repository_owner }}/\${{ inputs.service }}:\${{ inputs.version }} \\
            -n \${{ inputs.environment }}
          kubectl rollout status deployment/\${{ inputs.service }} -n \${{ inputs.environment }}

      - name: Inform Port - Success
        if: success()
        uses: port-labs/port-github-action@v1
        with:
          clientId: \${{ secrets.PORT_CLIENT_ID }}
          clientSecret: \${{ secrets.PORT_CLIENT_SECRET }}
          operation: PATCH_RUN
          runId: \${{ inputs.port_run_id }}
          status: SUCCESS
          logMessage: "‚úÖ Deployment completed successfully"
          summary: "Deployed \${{ inputs.version }} to \${{ inputs.environment }}"
          link: '["https://argocd.<YOUR_DOMAIN>/applications/\${{ inputs.service }}-\${{ inputs.environment }}"]'

      - name: Inform Port - Failure
        if: failure()
        uses: port-labs/port-github-action@v1
        with:
          clientId: \${{ secrets.PORT_CLIENT_ID }}
          clientSecret: \${{ secrets.PORT_CLIENT_SECRET }}
          operation: PATCH_RUN
          runId: \${{ inputs.port_run_id }}
          status: FAILURE
          logMessage: "‚ùå Deployment failed"
          summary: "Failed to deploy \${{ inputs.version }} to \${{ inputs.environment }}. Check workflow logs."
          link: '["https://github.com/\${{ github.repository }}/actions/runs/\${{ github.run_id }}"]'`,
                output: `Port run shows real-time progress:
1. "üöÄ Starting deployment..." (RUNNING)
2. "‚úÖ Deployment completed" (SUCCESS)
   - Summary: "Deployed v1.2.3 to production"
   - Link: ArgoCD application URL

Or on failure:
2. "‚ùå Deployment failed" (FAILURE)
   - Link: GitHub Actions run for debugging`,
                tags: ['action', 'github-actions', 'workflow', 'status']
            },

            // ==================== SCORECARDS ====================
            {
                category: 'scorecards',
                title: 'Production Readiness Scorecard',
                problem: 'Enforce and visualize service maturity standards',
                description: 'Multi-level scorecard with Bronze/Silver/Gold progression.',
                code: `{
  "identifier": "production_readiness",
  "title": "Production Readiness",
  "blueprint": "service",
  "rules": [
    {
      "identifier": "has_owner",
      "title": "Has designated owner",
      "level": "Bronze",
      "query": {
        "combinator": "and",
        "conditions": [
          { "operator": "isNotEmpty", "property": "owner" }
        ]
      }
    },
    {
      "identifier": "has_description",
      "title": "Has description",
      "level": "Bronze",
      "query": {
        "combinator": "and",
        "conditions": [
          { "operator": "isNotEmpty", "property": "description" }
        ]
      }
    },
    {
      "identifier": "has_runbook",
      "title": "Runbook documented",
      "level": "Silver",
      "query": {
        "combinator": "and",
        "conditions": [
          { "operator": "isNotEmpty", "property": "runbook_url" }
        ]
      }
    },
    {
      "identifier": "has_oncall",
      "title": "On-call configured",
      "level": "Silver",
      "query": {
        "combinator": "and",
        "conditions": [
          { "operator": "=", "property": "pagerduty_enabled", "value": true }
        ]
      }
    },
    {
      "identifier": "high_test_coverage",
      "title": "Test coverage > 80%",
      "level": "Gold",
      "query": {
        "combinator": "and",
        "conditions": [
          { "operator": ">=", "property": "test_coverage", "value": 80 }
        ]
      }
    },
    {
      "identifier": "no_critical_vulns",
      "title": "No critical vulnerabilities",
      "level": "Gold",
      "query": {
        "combinator": "and",
        "conditions": [
          { "operator": "=", "property": "$aggregation.critical_vulns_count", "value": 0 }
        ]
      }
    }
  ]
}`,
                output: `Service scorecard displays:
ü•â Bronze: 2/2 (has_owner ‚úì, has_description ‚úì)
ü•à Silver: 1/2 (has_runbook ‚úì, has_oncall ‚úó)
ü•á Gold: 0/2 (blocked by Silver)

Overall Level: Silver (67%)`,
                tags: ['scorecard', 'compliance', 'maturity', 'production-readiness']
            },
            {
                category: 'scorecards',
                title: 'Time-Based Freshness Rules',
                problem: 'Ensure services are actively maintained',
                description: 'Rules based on date comparisons for deployment freshness, dependency updates, etc.',
                code: `{
  "identifier": "operational_health",
  "title": "Operational Health",
  "blueprint": "service",
  "rules": [
    {
      "identifier": "deployed_last_30_days",
      "title": "Deployed in last 30 days",
      "level": "Bronze",
      "query": {
        "combinator": "and",
        "conditions": [
          {
            "operator": "between",
            "property": "last_deployed",
            "value": { "preset": "lastMonth" }
          }
        ]
      }
    },
    {
      "identifier": "deps_updated_quarterly",
      "title": "Dependencies updated in last 90 days",
      "level": "Silver",
      "query": {
        "combinator": "and",
        "conditions": [
          {
            "operator": "between",
            "property": "dependencies_updated_at",
            "value": { "preset": "last3Months" }
          }
        ]
      }
    },
    {
      "identifier": "no_stale_prs",
      "title": "No PRs older than 14 days",
      "level": "Gold",
      "query": {
        "combinator": "and",
        "conditions": [
          {
            "operator": "=",
            "property": "$aggregation.stale_pr_count",
            "value": 0
          }
        ]
      }
    }
  ]
}`,
                output: `Available presets for "between" operator:
- today, yesterday
- lastWeek, lastMonth, last3Months, last6Months, lastYear
- thisWeek, thisMonth, thisQuarter, thisYear

Rule passes if property date falls within preset range.`,
                tags: ['scorecard', 'time-based', 'freshness', 'date']
            },
            {
                category: 'scorecards',
                title: 'Mirror Property Rules',
                problem: 'Validate based on related entity properties',
                description: 'Use $mirror to check properties from parent/related entities.',
                code: `{
  "identifier": "security_compliance",
  "title": "Security Compliance",
  "blueprint": "service",
  "rules": [
    {
      "identifier": "team_has_security_champion",
      "title": "Team has security champion",
      "level": "Silver",
      "query": {
        "combinator": "and",
        "conditions": [
          {
            "operator": "isNotEmpty",
            "property": "$mirror.owning_team.security_champion"
          }
        ]
      }
    },
    {
      "identifier": "domain_soc2_compliant",
      "title": "Domain is SOC2 compliant",
      "level": "Gold",
      "query": {
        "combinator": "and",
        "conditions": [
          {
            "operator": "=",
            "property": "$mirror.domain.soc2_certified",
            "value": true
          }
        ]
      }
    },
    {
      "identifier": "cluster_is_hardened",
      "title": "Running on hardened cluster",
      "level": "Gold",
      "query": {
        "combinator": "and",
        "conditions": [
          {
            "operator": "containsAny",
            "property": "$mirror.cluster.security_features",
            "value": ["network-policies", "pod-security-admission"]
          }
        ]
      }
    }
  ]
}`,
                output: `Rule evaluates related entity properties:
- Checks owning_team.security_champion (1 hop)
- Checks domain.soc2_certified (1 hop)
- Checks cluster.security_features array (via deployment relation)

Service inherits compliance posture from its ecosystem.`,
                tags: ['scorecard', 'mirror', 'security', 'compliance', 'relations']
            },

            // ==================== AUTOMATIONS ====================
            {
                category: 'automations',
                title: 'Entity Created Automation',
                problem: 'Trigger onboarding workflow when new service is added',
                description: 'React to ENTITY_CREATED events with optional JQ conditions.',
                code: `{
  "identifier": "new_service_onboarding",
  "title": "New Service Onboarding",
  "trigger": {
    "type": "automation",
    "event": {
      "type": "ENTITY_CREATED",
      "blueprintIdentifier": "service"
    },
    "condition": {
      "type": "JQ",
      "expressions": [
        ".diff.after.properties.language == \"Python\"",
        ".diff.after.properties.tier <= 2"
      ],
      "combinator": "and"
    }
  },
  "invocationMethod": {
    "type": "GITHUB",
    "org": "<YOUR_ORG>",
    "repo": "platform-automation",
    "workflow": "onboard-service.yml",
    "workflowInputs": {
      "service_id": "{{.event.diff.after.identifier}}",
      "service_name": "{{.event.diff.after.title}}",
      "language": "{{.event.diff.after.properties.language}}",
      "owner": "{{.event.diff.after.properties.owner}}",
      "tier": "{{.event.diff.after.properties.tier}}"
    }
  }
}`,
                output: `Triggers when:
1. New service entity created
2. Language is "Python" AND tier is 1 or 2

Workflow receives entity data to:
- Set up monitoring dashboards
- Configure CI/CD templates
- Create Slack channel
- Add to on-call rotation`,
                tags: ['automation', 'entity-created', 'onboarding', 'trigger']
            },
            {
                category: 'automations',
                title: 'Property Changed Automation',
                problem: 'React when specific property changes (e.g., promoted to production)',
                description: 'Detect property value changes using diff comparison.',
                code: `{
  "identifier": "production_promotion_alert",
  "title": "Production Promotion Alert",
  "trigger": {
    "type": "automation",
    "event": {
      "type": "ENTITY_UPDATED",
      "blueprintIdentifier": "service"
    },
    "condition": {
      "type": "JQ",
      "expressions": [
        ".diff.before.properties.environment != \"production\"",
        ".diff.after.properties.environment == \"production\""
      ],
      "combinator": "and"
    }
  },
  "invocationMethod": {
    "type": "WEBHOOK",
    "url": "https://hooks.slack.com/services/<YOUR_WEBHOOK>",
    "method": "POST",
    "body": {
      "channel": "#platform-alerts",
      "username": "Port.io",
      "icon_emoji": ":rocket:",
      "blocks": [
        {
          "type": "header",
          "text": {
            "type": "plain_text",
            "text": "üöÄ Service Promoted to Production"
          }
        },
        {
          "type": "section",
          "fields": [
            { "type": "mrkdwn", "text": "*Service:*\\n{{.event.diff.after.title}}" },
            { "type": "mrkdwn", "text": "*Owner:*\\n{{.event.diff.after.properties.owner}}" }
          ]
        },
        {
          "type": "actions",
          "elements": [
            {
              "type": "button",
              "text": { "type": "plain_text", "text": "View in Port" },
              "url": "https://app.getport.io/serviceEntity/{{.event.diff.after.identifier}}"
            }
          ]
        }
      ]
    }
  }
}`,
                output: `Slack message sent when service.environment changes 
from anything ‚Üí "production":

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ üöÄ Service Promoted to Production  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Service: checkout-api              ‚îÇ
‚îÇ Owner: alice@company.com           ‚îÇ
‚îÇ [View in Port]                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò`,
                tags: ['automation', 'entity-updated', 'slack', 'notification', 'property-change']
            },
            {
                category: 'automations',
                title: 'Timer/Cron Automation',
                problem: 'Run scheduled tasks (cleanup, reports, syncs)',
                description: 'Trigger automations on a schedule using cron expressions.',
                code: `{
  "identifier": "weekly_compliance_report",
  "title": "Weekly Compliance Report",
  "trigger": {
    "type": "automation",
    "event": {
      "type": "TIMER",
      "interval": {
        "type": "CRON",
        "expression": "0 9 * * 1"
      }
    }
  },
  "invocationMethod": {
    "type": "WEBHOOK",
    "url": "https://<YOUR_DOMAIN>/api/compliance-report",
    "method": "POST",
    "headers": {
      "Authorization": "Bearer {{.secrets.REPORT_API_TOKEN}}",
      "Content-Type": "application/json"
    },
    "body": {
      "report_type": "weekly_compliance",
      "triggered_at": "{{.event.trigger.at}}"
    }
  }
}`,
                output: `Common cron expressions:
- "0 9 * * 1"      ‚Üí Monday 9am
- "0 0 * * *"      ‚Üí Daily midnight
- "0 */6 * * *"    ‚Üí Every 6 hours
- "0 9 1 * *"      ‚Üí First of month 9am
- "0 9 * * 1-5"    ‚Üí Weekdays 9am

Time is UTC. Use crontab.guru to build expressions.`,
                tags: ['automation', 'timer', 'cron', 'scheduled']
            },
            {
                category: 'automations',
                title: 'Scorecard Rule Failed Automation',
                problem: 'Auto-create Jira tickets when compliance rules fail',
                description: 'React to scorecard rule failures with ticket creation.',
                code: `{
  "identifier": "compliance_ticket_on_failure",
  "title": "Create Compliance Ticket",
  "trigger": {
    "type": "automation",
    "event": {
      "type": "SCORECARD_RULE_FAILED",
      "scorecard": "production_readiness",
      "rule": "has_runbook"
    }
  },
  "invocationMethod": {
    "type": "WEBHOOK",
    "url": "https://<YOUR_JIRA>/rest/api/2/issue",
    "method": "POST",
    "headers": {
      "Authorization": "Basic {{.secrets.JIRA_AUTH}}",
      "Content-Type": "application/json"
    },
    "body": {
      "fields": {
        "project": { "key": "PLAT" },
        "issuetype": { "name": "Task" },
        "summary": "[Compliance] {{.event.context.entity.title}} - Missing Runbook",
        "description": "Service *{{.event.context.entity.identifier}}* failed the 'has_runbook' rule in the Production Readiness scorecard.\\n\\n*Action Required:* Add a runbook URL to the service.\\n\\n[View in Port|https://app.getport.io/service/{{.event.context.entity.identifier}}]",
        "assignee": { "emailAddress": "{{.event.context.entity.properties.owner}}" },
        "labels": ["port-automation", "compliance", "runbook"]
      }
    }
  }
}`,
                output: `When service fails "has_runbook" rule:
1. Jira ticket created automatically
2. Assigned to service owner
3. Links back to Port entity

Closes the loop: Port tracks ‚Üí detects gap ‚Üí creates work item`,
                tags: ['automation', 'scorecard', 'jira', 'compliance', 'ticket']
            },

            // ==================== JQ PATTERNS ====================
            {
                category: 'jq',
                title: 'Property Access & Defaults',
                problem: 'Safely access properties that might be null/missing',
                description: 'Handle missing data with fallbacks and optional chaining.',
                code: `# Null coalescing - use default if null
.properties.owner // "unassigned"

# Nested access with fallback
.properties.config.timeout // 30

# Alternative/empty fallback
.properties.tags // []

# Check existence before access
if .properties.config then .properties.config.timeout else 30 end

# Multiple fallback chain
.properties.primary_owner // .properties.owner // .properties.team // "unknown"

# Safe array access
.properties.endpoints[0].url // "no endpoints"

# Conditional with type check
if (.properties.replicas | type) == "number" then .properties.replicas else 1 end`,
                output: `Given entity:
{ "properties": { "owner": null, "tags": ["api"] } }

.properties.owner // "unassigned"  ‚Üí "unassigned"
.properties.tags // []             ‚Üí ["api"]
.properties.missing // "default"   ‚Üí "default"`,
                tags: ['jq', 'null', 'default', 'safe-access']
            },
            {
                category: 'jq',
                title: 'String Operations',
                problem: 'Transform, combine, and extract from strings',
                description: 'Common string manipulations for identifiers and display names.',
                code: `# Convert case
.name | ascii_downcase                    # "MyService" ‚Üí "myservice"
.name | ascii_upcase                      # "MyService" ‚Üí "MYSERVICE"

# Replace characters
.name | gsub("-"; "_")                    # "my-service" ‚Üí "my_service"
.name | gsub("[^a-zA-Z0-9]"; "-")         # "my.service@v1" ‚Üí "my-service-v1"

# Split and join
.name | split("-")                        # "my-service" ‚Üí ["my", "service"]
.name | split("-") | join("_")            # "my-service" ‚Üí "my_service"

# Extract parts
.name | split("-")[0]                     # "my-service-api" ‚Üí "my"
.name | split("-")[1:]                    # "my-service-api" ‚Üí ["service", "api"]
.name | split("-")[-1]                    # "my-service-api" ‚Üí "api"

# String interpolation
"https://\\(.identifier).company.com"     # ‚Üí "https://my-service.company.com"

# Substring/slice
.name[0:3]                                # "myservice" ‚Üí "mys"
.name | .[0:1] | ascii_upcase             # "myservice" ‚Üí "M"

# Test/match
.name | test("^svc-")                     # "svc-api" ‚Üí true
.name | startswith("svc-")                # "svc-api" ‚Üí true
.name | endswith("-api")                  # "svc-api" ‚Üí true

# Title case (first letter uppercase)
.name | split("-") | map(.[0:1] | ascii_upcase + .[1:]) | join(" ")
# "my-service" ‚Üí "My Service"`,
                output: `Building identifiers:
(.metadata.namespace + "-" + .metadata.name)
‚Üí "production-checkout-api"

Display name from identifier:
.identifier | split("-") | map(.[0:1] | ascii_upcase + .[1:]) | join(" ")
‚Üí "Checkout Api"`,
                tags: ['jq', 'string', 'transform', 'case']
            },
            {
                category: 'jq',
                title: 'Array Operations',
                problem: 'Filter, transform, and aggregate arrays',
                description: 'Work with lists of tags, containers, dependencies, etc.',
                code: `# Filter array items
[.tags[] | select(. != "internal")]                    # Remove "internal" tag
[.tags[] | select(startswith("env-"))]                 # Only "env-*" tags
[.containers[] | select(.name != "sidecar")]           # Exclude sidecar

# Map/transform array
[.tags[] | ascii_downcase]                             # Lowercase all tags
[.containers[] | .name]                                # Extract container names
[.items[] | {name: .metadata.name, ns: .metadata.namespace}]

# Array contains
.tags | contains(["production"])                       # Has "production" tag?
.tags | any(. == "critical")                           # Any item is "critical"?
.tags | all(startswith("team-"))                       # All start with "team-"?

# Find in array
.containers[] | select(.name == "app") | .image        # Get app container image
first(.items[] | select(.status == "ready"))           # First ready item

# Array aggregation
.items | length                                        # Count items
[.items[].value] | add                                 # Sum values
[.items[].score] | add / length                        # Average

# Unique and sort
.tags | unique                                         # Remove duplicates
.tags | sort                                           # Sort alphabetically
[.items[] | .priority] | unique | sort                 # Unique sorted priorities

# Flatten nested arrays
[.teams[].members[]] | unique                          # All members across teams`,
                output: `Given: { "tags": ["API", "internal", "env-prod", "env-staging"] }

[.tags[] | select(startswith("env-"))]
‚Üí ["env-prod", "env-staging"]

[.tags[] | select(startswith("env-")) | split("-")[1]]
‚Üí ["prod", "staging"]`,
                tags: ['jq', 'array', 'filter', 'map']
            },
            {
                category: 'jq',
                title: 'Date & Time Calculations',
                problem: 'Calculate age, freshness, or time differences',
                description: 'Work with ISO dates for freshness checks and age calculations.',
                code: `# Current timestamp (Unix seconds)
now                                                    # 1704067200

# Parse ISO date to Unix timestamp
.created_at | fromdateiso8601                          # "2024-01-01T00:00:00Z" ‚Üí 1704067200

# Format Unix timestamp to ISO
now | todateiso8601                                    # ‚Üí "2024-01-01T00:00:00Z"

# Seconds since a date
now - (.last_deployed | fromdateiso8601)               # Seconds since deploy

# Days since a date
((now - (.last_deployed | fromdateiso8601)) / 86400) | floor

# Hours since a date
((now - (.updated_at | fromdateiso8601)) / 3600) | floor

# Is older than X days?
(now - (.created_at | fromdateiso8601)) > (30 * 86400) # Older than 30 days?

# Safe date calculation (handle null)
if .last_deployed then
  ((now - (.last_deployed | fromdateiso8601)) / 86400) | floor
else
  null
end

# Compare two dates
(.updated_at | fromdateiso8601) > (.created_at | fromdateiso8601)

# Time constants (seconds)
# 1 minute  = 60
# 1 hour    = 3600
# 1 day     = 86400
# 1 week    = 604800
# 30 days   = 2592000`,
                output: `Given: { "last_deployed": "2024-01-15T10:30:00Z" }
Now: 2024-01-20T10:30:00Z

Days since deploy:
((now - (.last_deployed | fromdateiso8601)) / 86400) | floor
‚Üí 5

Is stale (>7 days)?
(now - (.last_deployed | fromdateiso8601)) > (7 * 86400)
‚Üí false`,
                tags: ['jq', 'date', 'time', 'age', 'freshness']
            },
            {
                category: 'jq',
                title: 'Automation Condition Patterns',
                problem: 'Build conditions for automation triggers',
                description: 'Common patterns for detecting changes and filtering events.',
                code: `# Property changed
.diff.before.properties.status != .diff.after.properties.status

# Property changed TO specific value
.diff.before.properties.env != "prod" and .diff.after.properties.env == "prod"

# Property changed FROM specific value
.diff.before.properties.status == "active" and .diff.after.properties.status != "active"

# Any of multiple properties changed
(.diff.before.properties.owner != .diff.after.properties.owner) or
(.diff.before.properties.team != .diff.after.properties.team)

# Relation added
(.diff.before.relations.domain == null) and (.diff.after.relations.domain != null)

# Relation count increased
(.diff.after.relations.dependencies | length) > (.diff.before.relations.dependencies | length)

# New entity matches criteria
.diff.after.properties.tier == 1 and .diff.after.properties.pagerduty_enabled == true

# Exclude test entities
.diff.after.identifier | startswith("test-") | not

# Combined: prod + critical + not test
.diff.after.properties.environment == "prod" and
.diff.after.properties.critical == true and
(.diff.after.identifier | startswith("test-") | not)`,
                output: `Automation event structure:
{
  "event": {
    "diff": {
      "before": { "properties": {...}, "relations": {...} },
      "after": { "properties": {...}, "relations": {...} }
    }
  }
}

Conditions evaluate against this structure.
All expressions must return boolean.`,
                tags: ['jq', 'automation', 'condition', 'trigger', 'diff']
            },

            // ==================== API ====================
            {
                category: 'api',
                title: 'Authentication',
                problem: 'Get access token to call Port API',
                description: 'Exchange client credentials for JWT token.',
                code: `# Get access token
curl -X POST "https://api.getport.io/v1/auth/access_token" \\
  -H "Content-Type: application/json" \\
  -d '{
    "clientId": "<YOUR_CLIENT_ID>",
    "clientSecret": "<YOUR_CLIENT_SECRET>"
  }'

# Response contains accessToken (valid ~1 hour)
# Use in subsequent requests:
# -H "Authorization: Bearer <accessToken>"

# Shell script pattern
get_port_token() {
  curl -s -X POST "https://api.getport.io/v1/auth/access_token" \\
    -H "Content-Type: application/json" \\
    -d "{
      \\"clientId\\": \\"$PORT_CLIENT_ID\\",
      \\"clientSecret\\": \\"$PORT_CLIENT_SECRET\\"
    }" | jq -r '.accessToken'
}

TOKEN=$(get_port_token)
curl -H "Authorization: Bearer $TOKEN" ...`,
                output: `Response:
{
  "accessToken": "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...",
  "expiresIn": 3600,
  "tokenType": "Bearer"
}

Token valid for 1 hour. Cache and refresh as needed.`,
                tags: ['api', 'auth', 'token', 'credentials']
            },
            {
                category: 'api',
                title: 'Entity CRUD Operations',
                problem: 'Create, read, update, delete entities via API',
                description: 'Core entity operations with upsert pattern.',
                code: `# CREATE or UPDATE (upsert) - recommended pattern
curl -X POST "https://api.getport.io/v1/blueprints/service/entities?upsert=true&merge=true" \\
  -H "Authorization: Bearer $TOKEN" \\
  -H "Content-Type: application/json" \\
  -d '{
    "identifier": "checkout-api",
    "title": "Checkout API",
    "properties": {
      "language": "Python",
      "owner": "alice@company.com",
      "tier": 1
    },
    "relations": {
      "domain": "payments"
    }
  }'

# GET single entity
curl -X GET "https://api.getport.io/v1/blueprints/service/entities/checkout-api" \\
  -H "Authorization: Bearer $TOKEN"

# UPDATE (patch) - only specified fields
curl -X PATCH "https://api.getport.io/v1/blueprints/service/entities/checkout-api" \\
  -H "Authorization: Bearer $TOKEN" \\
  -H "Content-Type: application/json" \\
  -d '{
    "properties": {
      "status": "deployed",
      "last_deployed": "2024-01-20T15:30:00Z"
    }
  }'

# DELETE entity
curl -X DELETE "https://api.getport.io/v1/blueprints/service/entities/checkout-api" \\
  -H "Authorization: Bearer $TOKEN"

# DELETE with cascade (also delete related entities)
curl -X DELETE "https://api.getport.io/v1/blueprints/service/entities/checkout-api?delete_dependents=true" \\
  -H "Authorization: Bearer $TOKEN"`,
                output: `Upsert query params:
- upsert=true    ‚Üí create if not exists, update if exists
- merge=true     ‚Üí merge properties (don't overwrite unspecified)
- create_missing_related_entities=true ‚Üí auto-create relations

Response (201 created / 200 updated):
{
  "entity": {
    "identifier": "checkout-api",
    "title": "Checkout API",
    ...
  }
}`,
                tags: ['api', 'entity', 'crud', 'upsert']
            },
            {
                category: 'api',
                title: 'Search Entities',
                problem: 'Query entities with filters and pagination',
                description: 'Search with rules, combinators, and result limiting.',
                code: `# Search with filters
curl -X POST "https://api.getport.io/v1/blueprints/service/entities/search" \\
  -H "Authorization: Bearer $TOKEN" \\
  -H "Content-Type: application/json" \\
  -d '{
    "rules": [
      { "property": "language", "operator": "=", "value": "Python" },
      { "property": "tier", "operator": "<=", "value": 2 }
    ],
    "combinator": "and"
  }'

# Search with OR conditions
curl -X POST "https://api.getport.io/v1/blueprints/service/entities/search" \\
  -H "Authorization: Bearer $TOKEN" \\
  -H "Content-Type: application/json" \\
  -d '{
    "rules": [
      { "property": "status", "operator": "=", "value": "critical" },
      { "property": "status", "operator": "=", "value": "warning" }
    ],
    "combinator": "or"
  }'

# Search by relation
curl -X POST "https://api.getport.io/v1/blueprints/service/entities/search" \\
  -H "Authorization: Bearer $TOKEN" \\
  -H "Content-Type: application/json" \\
  -d '{
    "rules": [
      { "property": "$relation.domain", "operator": "=", "value": "payments" }
    ],
    "combinator": "and"
  }'

# Pagination
curl -X POST "https://api.getport.io/v1/blueprints/service/entities/search?page=1&per_page=50" \\
  -H "Authorization: Bearer $TOKEN" \\
  -d '{ "rules": [], "combinator": "and" }'`,
                output: `Operators:
=, !=, >, >=, <, <=
contains, doesNotContain (arrays)
beginsWith, endsWith, isEmpty, isNotEmpty

Response:
{
  "entities": [...],
  "totalCount": 142,
  "page": 1,
  "perPage": 50
}`,
                tags: ['api', 'search', 'query', 'filter']
            },
            {
                category: 'api',
                title: 'Action Run Updates',
                problem: 'Report action progress and completion to Port',
                description: 'Update run status with logs, summary, and links.',
                code: `# Update run status - IN PROGRESS
curl -X PATCH "https://api.getport.io/v1/actions/runs/$RUN_ID" \\
  -H "Authorization: Bearer $TOKEN" \\
  -H "Content-Type: application/json" \\
  -d '{
    "status": "RUNNING",
    "message": {
      "text": "Step 1/3: Building container image..."
    }
  }'

# Update run status - SUCCESS
curl -X PATCH "https://api.getport.io/v1/actions/runs/$RUN_ID" \\
  -H "Authorization: Bearer $TOKEN" \\
  -H "Content-Type: application/json" \\
  -d '{
    "status": "SUCCESS",
    "message": {
      "text": "Deployment completed successfully"
    },
    "summary": "Deployed v1.2.3 to production (3 replicas)",
    "link": [
      "https://argocd.company.com/applications/checkout-api",
      "https://grafana.company.com/d/checkout-api"
    ]
  }'

# Update run status - FAILURE
curl -X PATCH "https://api.getport.io/v1/actions/runs/$RUN_ID" \\
  -H "Authorization: Bearer $TOKEN" \\
  -H "Content-Type: application/json" \\
  -d '{
    "status": "FAILURE",
    "message": {
      "text": "Deployment failed: ImagePullBackOff on pod checkout-api-7d8f9b-xyz"
    },
    "summary": "Failed to deploy v1.2.3 - container image not found",
    "link": ["https://github.com/company/checkout-api/actions/runs/12345"]
  }'`,
                output: `Valid statuses:
- RUNNING   ‚Üí Action in progress (can send multiple)
- SUCCESS   ‚Üí Action completed successfully
- FAILURE   ‚Üí Action failed

Each PATCH with status=RUNNING adds a log entry.
Final status (SUCCESS/FAILURE) ends the run.

summary: Short text shown in run history
link: Array of URLs (shown as clickable links)`,
                tags: ['api', 'action', 'run', 'status', 'webhook']
            },
            {
                category: 'api',
                title: 'Bulk Operations',
                problem: 'Efficiently sync many entities',
                description: 'Patterns for bulk upsert with rate limiting consideration.',
                code: `#!/bin/bash
# Bulk upsert pattern with rate limiting

PORT_API="https://api.getport.io/v1"
BLUEPRINT="service"
BATCH_SIZE=50
DELAY_MS=100

# Get token
TOKEN=$(curl -s -X POST "$PORT_API/auth/access_token" \\
  -H "Content-Type: application/json" \\
  -d '{"clientId":"'$PORT_CLIENT_ID'","clientSecret":"'$PORT_CLIENT_SECRET'"}' \\
  | jq -r '.accessToken')

# Read entities from JSON file and upsert
upsert_entity() {
  local entity="$1"
  curl -s -X POST "$PORT_API/blueprints/$BLUEPRINT/entities?upsert=true&merge=true" \\
    -H "Authorization: Bearer $TOKEN" \\
    -H "Content-Type: application/json" \\
    -d "$entity"
}

# Process entities with rate limiting
cat entities.json | jq -c '.[]' | while read entity; do
  result=$(upsert_entity "$entity")
  identifier=$(echo "$entity" | jq -r '.identifier')
  
  if echo "$result" | jq -e '.entity' > /dev/null 2>&1; then
    echo "‚úì $identifier"
  else
    echo "‚úó $identifier: $(echo $result | jq -r '.message // .error')"
  fi
  
  sleep 0.1  # Rate limiting
done

# Python equivalent with retry
"""
import requests
from time import sleep
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

session = requests.Session()
retry = Retry(total=3, backoff_factor=0.5, status_forcelist=[429, 500, 502, 503])
session.mount('https://', HTTPAdapter(max_retries=retry))

def bulk_upsert(entities, blueprint='service'):
    for entity in entities:
        resp = session.post(
            f'{PORT_API}/blueprints/{blueprint}/entities',
            params={'upsert': 'true', 'merge': 'true'},
            headers={'Authorization': f'Bearer {token}'},
            json=entity
        )
        if resp.status_code == 429:
            sleep(int(resp.headers.get('Retry-After', 60)))
            continue
        yield entity['identifier'], resp.ok
        sleep(0.1)
"""`,
                output: `Rate limits:
- ~100 requests/second typical
- 429 response = back off (check Retry-After header)

Best practices:
- Batch with small delays (100ms)
- Implement retry with exponential backoff
- Use merge=true to preserve unspecified properties
- Log failures for manual review`,
                tags: ['api', 'bulk', 'sync', 'rate-limit', 'batch']
            }
        ];

        let activeCategory = 'all';
        let searchTerm = '';

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function detectLanguage(code, category) {
            // Detect language based on code content and category
            if (code.trim().startsWith('{') || code.trim().startsWith('[')) return 'json';
            if (code.trim().startsWith('resources:') || code.includes('kind:') || code.includes('mappings:')) return 'yaml';
            if (code.trim().startsWith('curl ') || code.trim().startsWith('#')) return 'bash';
            if (code.includes('def ') || code.includes('import ') || code.includes('class ')) return 'python';
            if (category === 'jq') return 'javascript'; // JQ is close enough to JS for highlighting
            if (category === 'api') return 'bash';
            return 'javascript';
        }

        function renderPatterns() {
            const grid = document.getElementById('patternGrid');
            const filtered = patterns.filter(p => {
                const matchesCategory = activeCategory === 'all' || p.category === activeCategory;
                const matchesSearch = !searchTerm || 
                    p.title.toLowerCase().includes(searchTerm.toLowerCase()) ||
                    p.description.toLowerCase().includes(searchTerm.toLowerCase()) ||
                    p.problem.toLowerCase().includes(searchTerm.toLowerCase()) ||
                    p.code.toLowerCase().includes(searchTerm.toLowerCase()) ||
                    p.tags.some(t => t.toLowerCase().includes(searchTerm.toLowerCase()));
                return matchesCategory && matchesSearch;
            });

            document.getElementById('status').textContent = 
                `Showing ${filtered.length} of ${patterns.length} patterns`;

            if (filtered.length === 0) {
                grid.innerHTML = `
                    <div class="no-results">
                        <h3 style="font-size: 1.5em; margin-bottom: 10px;">No patterns found</h3>
                        <p>Try adjusting your search or filter criteria</p>
                    </div>
                `;
                return;
            }

            grid.innerHTML = filtered.map((p, i) => `
                <div class="pattern-card">
                    <div class="pattern-header">
                        <h3 class="pattern-title">${escapeHtml(p.title)}</h3>
                        <p class="pattern-problem">üéØ ${escapeHtml(p.problem)}</p>
                        <p class="pattern-description">${escapeHtml(p.description)}</p>
                        <div class="tags">
                            ${p.tags.map(t => `<span class="tag">${escapeHtml(t)}</span>`).join('')}
                        </div>
                    </div>
                    <div class="code-section">
                        <div class="code-label">Code</div>
                        <div class="code-container">
                            <button class="copy-btn" data-code="${i}">Copy</button>
                            <pre class="language-${detectLanguage(p.code, p.category)}"><code class="language-${detectLanguage(p.code, p.category)}">${escapeHtml(p.code)}</code></pre>
                        </div>
                    </div>
                    ${p.output ? `
                    <div class="code-section output-section">
                        <div class="code-label">Result / Notes</div>
                        <div class="code-container">
                            <pre><code>${escapeHtml(p.output)}</code></pre>
                        </div>
                    </div>
                    ` : ''}
                </div>
            `).join('');

            document.querySelectorAll('.copy-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const index = parseInt(this.getAttribute('data-code'));
                    copyCode(this, filtered[index].code);
                });
            });

            // Highlight code with Prism
            if (typeof Prism !== 'undefined') {
                Prism.highlightAll();
            }
        }

        function copyCode(button, code) {
            navigator.clipboard.writeText(code).then(() => {
                button.textContent = 'Copied!';
                button.classList.add('copied');
                setTimeout(() => {
                    button.textContent = 'Copy';
                    button.classList.remove('copied');
                }, 2000);
            }).catch(err => {
                const textarea = document.createElement('textarea');
                textarea.value = code;
                textarea.style.position = 'fixed';
                textarea.style.opacity = '0';
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                button.textContent = 'Copied!';
                button.classList.add('copied');
                setTimeout(() => {
                    button.textContent = 'Copy';
                    button.classList.remove('copied');
                }, 2000);
            });
        }

        document.getElementById('searchBox').addEventListener('input', (e) => {
            searchTerm = e.target.value;
            renderPatterns();
        });

        document.querySelectorAll('.category-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('.category-btn').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                activeCategory = e.target.dataset.category;
                renderPatterns();
            });
        });

        renderPatterns();
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-yaml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script>
        // Re-render with Prism now loaded
        renderPatterns();
    </script>
</body>
</html>
